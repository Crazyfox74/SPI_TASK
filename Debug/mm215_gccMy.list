
mm215_gccMy.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000000  08000000  08000000  0002000c  2**0
                  CONTENTS
  1 .text         00001edc  08000000  08000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000024  08001edc  08001edc  00011edc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08001f00  08001f00  0002000c  2**0
                  CONTENTS
  4 .ARM          00000000  08001f00  08001f00  0002000c  2**0
                  CONTENTS
  5 .preinit_array 00000000  08001f00  08001f00  0002000c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08001f00  08001f00  00011f00  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  08001f04  08001f04  00011f04  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         0000000c  20000000  08001f08  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00004b1c  2000000c  08001f14  0002000c  2**2
                  ALLOC
 10 ._user_heap_stack 00000600  20004b28  08001f14  00024b28  2**0
                  ALLOC
 11 .ARM.attributes 00000030  00000000  00000000  0002000c  2**0
                  CONTENTS, READONLY
 12 .debug_info   0000cd6d  00000000  00000000  0002003c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 00001d39  00000000  00000000  0002cda9  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_loc    0000747a  00000000  00000000  0002eae2  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_aranges 000006c8  00000000  00000000  00035f60  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_ranges 00000960  00000000  00000000  00036628  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_macro  0001475c  00000000  00000000  00036f88  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_line   0000afcb  00000000  00000000  0004b6e4  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_str    0007fb8c  00000000  00000000  000566af  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .comment      00000050  00000000  00000000  000d623b  2**0
                  CONTENTS, READONLY
 21 .debug_frame  0000139c  00000000  00000000  000d628c  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08000000 <__do_global_dtors_aux>:
 8000000:	b510      	push	{r4, lr}
 8000002:	4c05      	ldr	r4, [pc, #20]	; (8000018 <__do_global_dtors_aux+0x18>)
 8000004:	7823      	ldrb	r3, [r4, #0]
 8000006:	b933      	cbnz	r3, 8000016 <__do_global_dtors_aux+0x16>
 8000008:	4b04      	ldr	r3, [pc, #16]	; (800001c <__do_global_dtors_aux+0x1c>)
 800000a:	b113      	cbz	r3, 8000012 <__do_global_dtors_aux+0x12>
 800000c:	4804      	ldr	r0, [pc, #16]	; (8000020 <__do_global_dtors_aux+0x20>)
 800000e:	f3af 8000 	nop.w
 8000012:	2301      	movs	r3, #1
 8000014:	7023      	strb	r3, [r4, #0]
 8000016:	bd10      	pop	{r4, pc}
 8000018:	2000000c 	.word	0x2000000c
 800001c:	00000000 	.word	0x00000000
 8000020:	08001ec4 	.word	0x08001ec4

08000024 <frame_dummy>:
 8000024:	b508      	push	{r3, lr}
 8000026:	4b03      	ldr	r3, [pc, #12]	; (8000034 <frame_dummy+0x10>)
 8000028:	b11b      	cbz	r3, 8000032 <frame_dummy+0xe>
 800002a:	4903      	ldr	r1, [pc, #12]	; (8000038 <frame_dummy+0x14>)
 800002c:	4803      	ldr	r0, [pc, #12]	; (800003c <frame_dummy+0x18>)
 800002e:	f3af 8000 	nop.w
 8000032:	bd08      	pop	{r3, pc}
 8000034:	00000000 	.word	0x00000000
 8000038:	20000010 	.word	0x20000010
 800003c:	08001ec4 	.word	0x08001ec4

08000040 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8000040:	f100 0308 	add.w	r3, r0, #8
 8000044:	6043      	str	r3, [r0, #4]

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
 8000046:	f04f 32ff 	mov.w	r2, #4294967295
 800004a:	6082      	str	r2, [r0, #8]

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800004c:	60c3      	str	r3, [r0, #12]
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800004e:	6103      	str	r3, [r0, #16]

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8000050:	2300      	movs	r3, #0
 8000052:	6003      	str	r3, [r0, #0]

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 8000054:	4770      	bx	lr

08000056 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
 8000056:	2300      	movs	r3, #0
 8000058:	6103      	str	r3, [r0, #16]

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 800005a:	4770      	bx	lr

0800005c <vListInsert>:
}
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
 800005c:	b430      	push	{r4, r5}
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 800005e:	680d      	ldr	r5, [r1, #0]
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
 8000060:	f1b5 3fff 	cmp.w	r5, #4294967295
 8000064:	d011      	beq.n	800008a <vListInsert+0x2e>
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 8000066:	f100 0308 	add.w	r3, r0, #8
 800006a:	461c      	mov	r4, r3
 800006c:	685b      	ldr	r3, [r3, #4]
 800006e:	681a      	ldr	r2, [r3, #0]
 8000070:	42aa      	cmp	r2, r5
 8000072:	d9fa      	bls.n	800006a <vListInsert+0xe>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
 8000074:	6863      	ldr	r3, [r4, #4]
 8000076:	604b      	str	r3, [r1, #4]
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 8000078:	6099      	str	r1, [r3, #8]
    pxNewListItem->pxPrevious = pxIterator;
 800007a:	608c      	str	r4, [r1, #8]
    pxIterator->pxNext = pxNewListItem;
 800007c:	6061      	str	r1, [r4, #4]

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
 800007e:	6108      	str	r0, [r1, #16]

    ( pxList->uxNumberOfItems )++;
 8000080:	6803      	ldr	r3, [r0, #0]
 8000082:	3301      	adds	r3, #1
 8000084:	6003      	str	r3, [r0, #0]
}
 8000086:	bc30      	pop	{r4, r5}
 8000088:	4770      	bx	lr
        pxIterator = pxList->xListEnd.pxPrevious;
 800008a:	6904      	ldr	r4, [r0, #16]
 800008c:	e7f2      	b.n	8000074 <vListInsert+0x18>

0800008e <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
 800008e:	6903      	ldr	r3, [r0, #16]

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8000090:	6841      	ldr	r1, [r0, #4]
 8000092:	6882      	ldr	r2, [r0, #8]
 8000094:	608a      	str	r2, [r1, #8]
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8000096:	6841      	ldr	r1, [r0, #4]
 8000098:	6051      	str	r1, [r2, #4]

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
 800009a:	685a      	ldr	r2, [r3, #4]
 800009c:	4282      	cmp	r2, r0
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
 800009e:	bf04      	itt	eq
 80000a0:	6882      	ldreq	r2, [r0, #8]
 80000a2:	605a      	streq	r2, [r3, #4]
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
 80000a4:	2200      	movs	r2, #0
 80000a6:	6102      	str	r2, [r0, #16]
    ( pxList->uxNumberOfItems )--;
 80000a8:	681a      	ldr	r2, [r3, #0]
 80000aa:	3a01      	subs	r2, #1
 80000ac:	601a      	str	r2, [r3, #0]

    return pxList->uxNumberOfItems;
 80000ae:	6818      	ldr	r0, [r3, #0]
}
 80000b0:	4770      	bx	lr

080000b2 <prvIsQueueEmpty>:
    taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
 80000b2:	b510      	push	{r4, lr}
 80000b4:	4604      	mov	r4, r0
    BaseType_t xReturn;

    taskENTER_CRITICAL();
 80000b6:	f001 fab3 	bl	8001620 <vPortEnterCritical>
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
 80000ba:	6ba4      	ldr	r4, [r4, #56]	; 0x38
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
 80000bc:	f001 fad2 	bl	8001664 <vPortExitCritical>

    return xReturn;
}
 80000c0:	fab4 f084 	clz	r0, r4
 80000c4:	0940      	lsrs	r0, r0, #5
 80000c6:	bd10      	pop	{r4, pc}

080000c8 <prvCopyDataToQueue>:
{
 80000c8:	b570      	push	{r4, r5, r6, lr}
 80000ca:	4604      	mov	r4, r0
 80000cc:	4615      	mov	r5, r2
    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 80000ce:	6b86      	ldr	r6, [r0, #56]	; 0x38
    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 80000d0:	6c02      	ldr	r2, [r0, #64]	; 0x40
 80000d2:	b95a      	cbnz	r2, 80000ec <prvCopyDataToQueue+0x24>
                if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 80000d4:	6803      	ldr	r3, [r0, #0]
 80000d6:	b11b      	cbz	r3, 80000e0 <prvCopyDataToQueue+0x18>
    BaseType_t xReturn = pdFALSE;
 80000d8:	2000      	movs	r0, #0
    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 80000da:	3601      	adds	r6, #1
 80000dc:	63a6      	str	r6, [r4, #56]	; 0x38
}
 80000de:	bd70      	pop	{r4, r5, r6, pc}
                    xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
 80000e0:	6880      	ldr	r0, [r0, #8]
 80000e2:	f001 f845 	bl	8001170 <xTaskPriorityDisinherit>
                    pxQueue->u.xSemaphore.xMutexHolder = NULL;
 80000e6:	2300      	movs	r3, #0
 80000e8:	60a3      	str	r3, [r4, #8]
 80000ea:	e7f6      	b.n	80000da <prvCopyDataToQueue+0x12>
    else if( xPosition == queueSEND_TO_BACK )
 80000ec:	b96d      	cbnz	r5, 800010a <prvCopyDataToQueue+0x42>
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 80000ee:	6840      	ldr	r0, [r0, #4]
 80000f0:	f001 fed2 	bl	8001e98 <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 80000f4:	6863      	ldr	r3, [r4, #4]
 80000f6:	6c22      	ldr	r2, [r4, #64]	; 0x40
 80000f8:	4413      	add	r3, r2
 80000fa:	6063      	str	r3, [r4, #4]
        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 80000fc:	68a2      	ldr	r2, [r4, #8]
 80000fe:	4293      	cmp	r3, r2
 8000100:	d319      	bcc.n	8000136 <prvCopyDataToQueue+0x6e>
            pxQueue->pcWriteTo = pxQueue->pcHead;
 8000102:	6823      	ldr	r3, [r4, #0]
 8000104:	6063      	str	r3, [r4, #4]
    BaseType_t xReturn = pdFALSE;
 8000106:	4628      	mov	r0, r5
 8000108:	e7e7      	b.n	80000da <prvCopyDataToQueue+0x12>
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
 800010a:	68c0      	ldr	r0, [r0, #12]
 800010c:	f001 fec4 	bl	8001e98 <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 8000110:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8000112:	4251      	negs	r1, r2
 8000114:	68e3      	ldr	r3, [r4, #12]
 8000116:	1a9b      	subs	r3, r3, r2
 8000118:	60e3      	str	r3, [r4, #12]
        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 800011a:	6822      	ldr	r2, [r4, #0]
 800011c:	4293      	cmp	r3, r2
 800011e:	d202      	bcs.n	8000126 <prvCopyDataToQueue+0x5e>
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
 8000120:	68a3      	ldr	r3, [r4, #8]
 8000122:	440b      	add	r3, r1
 8000124:	60e3      	str	r3, [r4, #12]
        if( xPosition == queueOVERWRITE )
 8000126:	2d02      	cmp	r5, #2
 8000128:	d001      	beq.n	800012e <prvCopyDataToQueue+0x66>
    BaseType_t xReturn = pdFALSE;
 800012a:	2000      	movs	r0, #0
 800012c:	e7d5      	b.n	80000da <prvCopyDataToQueue+0x12>
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 800012e:	b126      	cbz	r6, 800013a <prvCopyDataToQueue+0x72>
                --uxMessagesWaiting;
 8000130:	3e01      	subs	r6, #1
    BaseType_t xReturn = pdFALSE;
 8000132:	2000      	movs	r0, #0
 8000134:	e7d1      	b.n	80000da <prvCopyDataToQueue+0x12>
 8000136:	4628      	mov	r0, r5
 8000138:	e7cf      	b.n	80000da <prvCopyDataToQueue+0x12>
 800013a:	2000      	movs	r0, #0
 800013c:	e7cd      	b.n	80000da <prvCopyDataToQueue+0x12>

0800013e <prvNotifyQueueSetContainer>:
/*-----------------------------------------------------------*/

#if ( configUSE_QUEUE_SETS == 1 )

    static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue )
    {
 800013e:	b570      	push	{r4, r5, r6, lr}
 8000140:	b082      	sub	sp, #8
 8000142:	9001      	str	r0, [sp, #4]
        Queue_t * pxQueueSetContainer = pxQueue->pxQueueSetContainer;
 8000144:	6c84      	ldr	r4, [r0, #72]	; 0x48
        /* This function must be called form a critical section. */

        /* The following line is not reachable in unit tests because every call
         * to prvNotifyQueueSetContainer is preceded by a check that
         * pxQueueSetContainer != NULL */
        configASSERT( pxQueueSetContainer ); /* LCOV_EXCL_BR_LINE */
 8000146:	b164      	cbz	r4, 8000162 <prvNotifyQueueSetContainer+0x24>
        configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
 8000148:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 800014a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800014c:	429a      	cmp	r2, r3
 800014e:	d311      	bcc.n	8000174 <prvNotifyQueueSetContainer+0x36>

    portFORCE_INLINE static void vPortRaiseBASEPRI( void )
    {
        uint32_t ulNewBASEPRI;

        __asm volatile
 8000150:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000154:	f383 8811 	msr	BASEPRI, r3
 8000158:	f3bf 8f6f 	isb	sy
 800015c:	f3bf 8f4f 	dsb	sy
 8000160:	e7fe      	b.n	8000160 <prvNotifyQueueSetContainer+0x22>
 8000162:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000166:	f383 8811 	msr	BASEPRI, r3
 800016a:	f3bf 8f6f 	isb	sy
 800016e:	f3bf 8f4f 	dsb	sy
        configASSERT( pxQueueSetContainer ); /* LCOV_EXCL_BR_LINE */
 8000172:	e7fe      	b.n	8000172 <prvNotifyQueueSetContainer+0x34>

        if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
 8000174:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8000176:	4293      	cmp	r3, r2
 8000178:	d803      	bhi.n	8000182 <prvNotifyQueueSetContainer+0x44>
        BaseType_t xReturn = pdFALSE;
 800017a:	2500      	movs	r5, #0
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    }
 800017c:	4628      	mov	r0, r5
 800017e:	b002      	add	sp, #8
 8000180:	bd70      	pop	{r4, r5, r6, pc}
            const int8_t cTxLock = pxQueueSetContainer->cTxLock;
 8000182:	f894 6045 	ldrb.w	r6, [r4, #69]	; 0x45
 8000186:	b276      	sxtb	r6, r6
            xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, queueSEND_TO_BACK );
 8000188:	2200      	movs	r2, #0
 800018a:	a901      	add	r1, sp, #4
 800018c:	4620      	mov	r0, r4
 800018e:	f7ff ff9b 	bl	80000c8 <prvCopyDataToQueue>
 8000192:	4605      	mov	r5, r0
            if( cTxLock == queueUNLOCKED )
 8000194:	f1b6 3fff 	cmp.w	r6, #4294967295
 8000198:	d006      	beq.n	80001a8 <prvNotifyQueueSetContainer+0x6a>
                configASSERT( cTxLock != queueINT8_MAX );
 800019a:	2e7f      	cmp	r6, #127	; 0x7f
 800019c:	d00f      	beq.n	80001be <prvNotifyQueueSetContainer+0x80>
                pxQueueSetContainer->cTxLock = ( int8_t ) ( cTxLock + 1 );
 800019e:	1c73      	adds	r3, r6, #1
 80001a0:	b25b      	sxtb	r3, r3
 80001a2:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 80001a6:	e7e9      	b.n	800017c <prvNotifyQueueSetContainer+0x3e>
                if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
 80001a8:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80001aa:	2b00      	cmp	r3, #0
 80001ac:	d0e6      	beq.n	800017c <prvNotifyQueueSetContainer+0x3e>
                    if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
 80001ae:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80001b2:	f000 fef3 	bl	8000f9c <xTaskRemoveFromEventList>
                        xReturn = pdTRUE;
 80001b6:	2800      	cmp	r0, #0
 80001b8:	bf18      	it	ne
 80001ba:	2501      	movne	r5, #1
 80001bc:	e7de      	b.n	800017c <prvNotifyQueueSetContainer+0x3e>
 80001be:	f04f 0350 	mov.w	r3, #80	; 0x50
 80001c2:	f383 8811 	msr	BASEPRI, r3
 80001c6:	f3bf 8f6f 	isb	sy
 80001ca:	f3bf 8f4f 	dsb	sy
                configASSERT( cTxLock != queueINT8_MAX );
 80001ce:	e7fe      	b.n	80001ce <prvNotifyQueueSetContainer+0x90>

080001d0 <prvCopyDataFromQueue>:
{
 80001d0:	4603      	mov	r3, r0
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 80001d2:	6c02      	ldr	r2, [r0, #64]	; 0x40
 80001d4:	b16a      	cbz	r2, 80001f2 <prvCopyDataFromQueue+0x22>
{
 80001d6:	b510      	push	{r4, lr}
 80001d8:	4608      	mov	r0, r1
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 80001da:	68d9      	ldr	r1, [r3, #12]
 80001dc:	4411      	add	r1, r2
 80001de:	60d9      	str	r1, [r3, #12]
        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 80001e0:	689c      	ldr	r4, [r3, #8]
 80001e2:	42a1      	cmp	r1, r4
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 80001e4:	bf24      	itt	cs
 80001e6:	6819      	ldrcs	r1, [r3, #0]
 80001e8:	60d9      	strcs	r1, [r3, #12]
        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 80001ea:	68d9      	ldr	r1, [r3, #12]
 80001ec:	f001 fe54 	bl	8001e98 <memcpy>
}
 80001f0:	bd10      	pop	{r4, pc}
 80001f2:	4770      	bx	lr

080001f4 <prvUnlockQueue>:
{
 80001f4:	b570      	push	{r4, r5, r6, lr}
 80001f6:	4605      	mov	r5, r0
    taskENTER_CRITICAL();
 80001f8:	f001 fa12 	bl	8001620 <vPortEnterCritical>
        int8_t cTxLock = pxQueue->cTxLock;
 80001fc:	f895 4045 	ldrb.w	r4, [r5, #69]	; 0x45
 8000200:	b264      	sxtb	r4, r4
        while( cTxLock > queueLOCKED_UNMODIFIED )
 8000202:	2c00      	cmp	r4, #0
 8000204:	dd19      	ble.n	800023a <prvUnlockQueue+0x46>
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8000206:	f105 0624 	add.w	r6, r5, #36	; 0x24
 800020a:	e008      	b.n	800021e <prvUnlockQueue+0x2a>
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 800020c:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 800020e:	b1a3      	cbz	r3, 800023a <prvUnlockQueue+0x46>
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8000210:	4630      	mov	r0, r6
 8000212:	f000 fec3 	bl	8000f9c <xTaskRemoveFromEventList>
 8000216:	b968      	cbnz	r0, 8000234 <prvUnlockQueue+0x40>
            --cTxLock;
 8000218:	3c01      	subs	r4, #1
 800021a:	b264      	sxtb	r4, r4
        while( cTxLock > queueLOCKED_UNMODIFIED )
 800021c:	b16c      	cbz	r4, 800023a <prvUnlockQueue+0x46>
                    if( pxQueue->pxQueueSetContainer != NULL )
 800021e:	6cab      	ldr	r3, [r5, #72]	; 0x48
 8000220:	2b00      	cmp	r3, #0
 8000222:	d0f3      	beq.n	800020c <prvUnlockQueue+0x18>
                        if( prvNotifyQueueSetContainer( pxQueue ) != pdFALSE )
 8000224:	4628      	mov	r0, r5
 8000226:	f7ff ff8a 	bl	800013e <prvNotifyQueueSetContainer>
 800022a:	2800      	cmp	r0, #0
 800022c:	d0f4      	beq.n	8000218 <prvUnlockQueue+0x24>
                            vTaskMissedYield();
 800022e:	f000 ff89 	bl	8001144 <vTaskMissedYield>
 8000232:	e7f1      	b.n	8000218 <prvUnlockQueue+0x24>
                                vTaskMissedYield();
 8000234:	f000 ff86 	bl	8001144 <vTaskMissedYield>
 8000238:	e7ee      	b.n	8000218 <prvUnlockQueue+0x24>
        pxQueue->cTxLock = queueUNLOCKED;
 800023a:	23ff      	movs	r3, #255	; 0xff
 800023c:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
    taskEXIT_CRITICAL();
 8000240:	f001 fa10 	bl	8001664 <vPortExitCritical>
    taskENTER_CRITICAL();
 8000244:	f001 f9ec 	bl	8001620 <vPortEnterCritical>
        int8_t cRxLock = pxQueue->cRxLock;
 8000248:	f895 4044 	ldrb.w	r4, [r5, #68]	; 0x44
 800024c:	b264      	sxtb	r4, r4
        while( cRxLock > queueLOCKED_UNMODIFIED )
 800024e:	2c00      	cmp	r4, #0
 8000250:	dd0f      	ble.n	8000272 <prvUnlockQueue+0x7e>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8000252:	f105 0610 	add.w	r6, r5, #16
 8000256:	e002      	b.n	800025e <prvUnlockQueue+0x6a>
                --cRxLock;
 8000258:	3c01      	subs	r4, #1
 800025a:	b264      	sxtb	r4, r4
        while( cRxLock > queueLOCKED_UNMODIFIED )
 800025c:	b14c      	cbz	r4, 8000272 <prvUnlockQueue+0x7e>
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800025e:	692b      	ldr	r3, [r5, #16]
 8000260:	b13b      	cbz	r3, 8000272 <prvUnlockQueue+0x7e>
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8000262:	4630      	mov	r0, r6
 8000264:	f000 fe9a 	bl	8000f9c <xTaskRemoveFromEventList>
 8000268:	2800      	cmp	r0, #0
 800026a:	d0f5      	beq.n	8000258 <prvUnlockQueue+0x64>
                    vTaskMissedYield();
 800026c:	f000 ff6a 	bl	8001144 <vTaskMissedYield>
 8000270:	e7f2      	b.n	8000258 <prvUnlockQueue+0x64>
        pxQueue->cRxLock = queueUNLOCKED;
 8000272:	23ff      	movs	r3, #255	; 0xff
 8000274:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
    taskEXIT_CRITICAL();
 8000278:	f001 f9f4 	bl	8001664 <vPortExitCritical>
}
 800027c:	bd70      	pop	{r4, r5, r6, pc}

0800027e <xQueueGenericReset>:
{
 800027e:	b538      	push	{r3, r4, r5, lr}
    configASSERT( pxQueue );
 8000280:	b180      	cbz	r0, 80002a4 <xQueueGenericReset+0x26>
 8000282:	460d      	mov	r5, r1
 8000284:	4604      	mov	r4, r0
        ( pxQueue->uxLength >= 1U ) &&
 8000286:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
    if( ( pxQueue != NULL ) &&
 8000288:	b11b      	cbz	r3, 8000292 <xQueueGenericReset+0x14>
        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
 800028a:	6c02      	ldr	r2, [r0, #64]	; 0x40
 800028c:	fba2 2303 	umull	r2, r3, r2, r3
        ( pxQueue->uxLength >= 1U ) &&
 8000290:	b18b      	cbz	r3, 80002b6 <xQueueGenericReset+0x38>
 8000292:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000296:	f383 8811 	msr	BASEPRI, r3
 800029a:	f3bf 8f6f 	isb	sy
 800029e:	f3bf 8f4f 	dsb	sy
    configASSERT( xReturn != pdFAIL );
 80002a2:	e7fe      	b.n	80002a2 <xQueueGenericReset+0x24>
 80002a4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80002a8:	f383 8811 	msr	BASEPRI, r3
 80002ac:	f3bf 8f6f 	isb	sy
 80002b0:	f3bf 8f4f 	dsb	sy
    configASSERT( pxQueue );
 80002b4:	e7fe      	b.n	80002b4 <xQueueGenericReset+0x36>
        taskENTER_CRITICAL();
 80002b6:	f001 f9b3 	bl	8001620 <vPortEnterCritical>
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 80002ba:	6822      	ldr	r2, [r4, #0]
 80002bc:	6c21      	ldr	r1, [r4, #64]	; 0x40
 80002be:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80002c0:	fb01 f303 	mul.w	r3, r1, r3
 80002c4:	18d0      	adds	r0, r2, r3
 80002c6:	60a0      	str	r0, [r4, #8]
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 80002c8:	2000      	movs	r0, #0
 80002ca:	63a0      	str	r0, [r4, #56]	; 0x38
            pxQueue->pcWriteTo = pxQueue->pcHead;
 80002cc:	6062      	str	r2, [r4, #4]
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 80002ce:	1a5b      	subs	r3, r3, r1
 80002d0:	4413      	add	r3, r2
 80002d2:	60e3      	str	r3, [r4, #12]
            pxQueue->cRxLock = queueUNLOCKED;
 80002d4:	23ff      	movs	r3, #255	; 0xff
 80002d6:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
            pxQueue->cTxLock = queueUNLOCKED;
 80002da:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
            if( xNewQueue == pdFALSE )
 80002de:	b9b5      	cbnz	r5, 800030e <xQueueGenericReset+0x90>
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 80002e0:	6923      	ldr	r3, [r4, #16]
 80002e2:	b91b      	cbnz	r3, 80002ec <xQueueGenericReset+0x6e>
        taskEXIT_CRITICAL();
 80002e4:	f001 f9be 	bl	8001664 <vPortExitCritical>
}
 80002e8:	2001      	movs	r0, #1
 80002ea:	bd38      	pop	{r3, r4, r5, pc}
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80002ec:	f104 0010 	add.w	r0, r4, #16
 80002f0:	f000 fe54 	bl	8000f9c <xTaskRemoveFromEventList>
 80002f4:	2800      	cmp	r0, #0
 80002f6:	d0f5      	beq.n	80002e4 <xQueueGenericReset+0x66>
                        queueYIELD_IF_USING_PREEMPTION();
 80002f8:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80002fc:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8000300:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8000304:	f3bf 8f4f 	dsb	sy
 8000308:	f3bf 8f6f 	isb	sy
 800030c:	e7ea      	b.n	80002e4 <xQueueGenericReset+0x66>
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 800030e:	f104 0010 	add.w	r0, r4, #16
 8000312:	f7ff fe95 	bl	8000040 <vListInitialise>
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 8000316:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800031a:	f7ff fe91 	bl	8000040 <vListInitialise>
 800031e:	e7e1      	b.n	80002e4 <xQueueGenericReset+0x66>

08000320 <xQueueGenericCreateStatic>:
        configASSERT( pxStaticQueue );
 8000320:	b173      	cbz	r3, 8000340 <xQueueGenericCreateStatic+0x20>
    {
 8000322:	b510      	push	{r4, lr}
 8000324:	b082      	sub	sp, #8
 8000326:	461c      	mov	r4, r3
        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
 8000328:	b108      	cbz	r0, 800032e <xQueueGenericCreateStatic+0xe>
            ( pxStaticQueue != NULL ) &&
 800032a:	b192      	cbz	r2, 8000352 <xQueueGenericCreateStatic+0x32>
            ( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) ) &&
 800032c:	b9f1      	cbnz	r1, 800036c <xQueueGenericCreateStatic+0x4c>
 800032e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000332:	f383 8811 	msr	BASEPRI, r3
 8000336:	f3bf 8f6f 	isb	sy
 800033a:	f3bf 8f4f 	dsb	sy
            configASSERT( pxNewQueue );
 800033e:	e7fe      	b.n	800033e <xQueueGenericCreateStatic+0x1e>
 8000340:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000344:	f383 8811 	msr	BASEPRI, r3
 8000348:	f3bf 8f6f 	isb	sy
 800034c:	f3bf 8f4f 	dsb	sy
        configASSERT( pxStaticQueue );
 8000350:	e7fe      	b.n	8000350 <xQueueGenericCreateStatic+0x30>
            ( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) ) )
 8000352:	2900      	cmp	r1, #0
 8000354:	d1eb      	bne.n	800032e <xQueueGenericCreateStatic+0xe>
                    volatile size_t xSize = sizeof( StaticQueue_t );
 8000356:	2354      	movs	r3, #84	; 0x54
 8000358:	9301      	str	r3, [sp, #4]
                    configASSERT( xSize == sizeof( Queue_t ) ); /* LCOV_EXCL_BR_LINE */
 800035a:	9b01      	ldr	r3, [sp, #4]
 800035c:	2b54      	cmp	r3, #84	; 0x54
 800035e:	d10a      	bne.n	8000376 <xQueueGenericCreateStatic+0x56>
                    ( void ) xSize;                             /* Keeps lint quiet when configASSERT() is not defined. */
 8000360:	9b01      	ldr	r3, [sp, #4]
                    pxNewQueue->ucStaticallyAllocated = pdTRUE;
 8000362:	2301      	movs	r3, #1
 8000364:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 8000368:	4622      	mov	r2, r4
 800036a:	e011      	b.n	8000390 <xQueueGenericCreateStatic+0x70>
                    volatile size_t xSize = sizeof( StaticQueue_t );
 800036c:	2354      	movs	r3, #84	; 0x54
 800036e:	9301      	str	r3, [sp, #4]
                    configASSERT( xSize == sizeof( Queue_t ) ); /* LCOV_EXCL_BR_LINE */
 8000370:	9b01      	ldr	r3, [sp, #4]
 8000372:	2b54      	cmp	r3, #84	; 0x54
 8000374:	d008      	beq.n	8000388 <xQueueGenericCreateStatic+0x68>
 8000376:	f04f 0350 	mov.w	r3, #80	; 0x50
 800037a:	f383 8811 	msr	BASEPRI, r3
 800037e:	f3bf 8f6f 	isb	sy
 8000382:	f3bf 8f4f 	dsb	sy
 8000386:	e7fe      	b.n	8000386 <xQueueGenericCreateStatic+0x66>
                    ( void ) xSize;                             /* Keeps lint quiet when configASSERT() is not defined. */
 8000388:	9b01      	ldr	r3, [sp, #4]
                    pxNewQueue->ucStaticallyAllocated = pdTRUE;
 800038a:	2301      	movs	r3, #1
 800038c:	f884 3046 	strb.w	r3, [r4, #70]	; 0x46
    if( uxItemSize == ( UBaseType_t ) 0 )
 8000390:	6022      	str	r2, [r4, #0]
    pxNewQueue->uxLength = uxQueueLength;
 8000392:	63e0      	str	r0, [r4, #60]	; 0x3c
    pxNewQueue->uxItemSize = uxItemSize;
 8000394:	6421      	str	r1, [r4, #64]	; 0x40
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 8000396:	2101      	movs	r1, #1
 8000398:	4620      	mov	r0, r4
 800039a:	f7ff ff70 	bl	800027e <xQueueGenericReset>
            pxNewQueue->ucQueueType = ucQueueType;
 800039e:	f89d 3010 	ldrb.w	r3, [sp, #16]
 80003a2:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
            pxNewQueue->pxQueueSetContainer = NULL;
 80003a6:	2300      	movs	r3, #0
 80003a8:	64a3      	str	r3, [r4, #72]	; 0x48
    }
 80003aa:	4620      	mov	r0, r4
 80003ac:	b002      	add	sp, #8
 80003ae:	bd10      	pop	{r4, pc}

080003b0 <xQueueReceive>:
{
 80003b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80003b4:	b084      	sub	sp, #16
 80003b6:	9201      	str	r2, [sp, #4]
    configASSERT( ( pxQueue ) );
 80003b8:	b180      	cbz	r0, 80003dc <xQueueReceive+0x2c>
 80003ba:	460e      	mov	r6, r1
 80003bc:	4604      	mov	r4, r0
    configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80003be:	b1b1      	cbz	r1, 80003ee <xQueueReceive+0x3e>
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 80003c0:	f000 fec6 	bl	8001150 <xTaskGetSchedulerState>
 80003c4:	b9f8      	cbnz	r0, 8000406 <xQueueReceive+0x56>
 80003c6:	9b01      	ldr	r3, [sp, #4]
 80003c8:	b30b      	cbz	r3, 800040e <xQueueReceive+0x5e>
 80003ca:	f04f 0350 	mov.w	r3, #80	; 0x50
 80003ce:	f383 8811 	msr	BASEPRI, r3
 80003d2:	f3bf 8f6f 	isb	sy
 80003d6:	f3bf 8f4f 	dsb	sy
 80003da:	e7fe      	b.n	80003da <xQueueReceive+0x2a>
 80003dc:	f04f 0350 	mov.w	r3, #80	; 0x50
 80003e0:	f383 8811 	msr	BASEPRI, r3
 80003e4:	f3bf 8f6f 	isb	sy
 80003e8:	f3bf 8f4f 	dsb	sy
    configASSERT( ( pxQueue ) );
 80003ec:	e7fe      	b.n	80003ec <xQueueReceive+0x3c>
    configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 80003ee:	6c03      	ldr	r3, [r0, #64]	; 0x40
 80003f0:	2b00      	cmp	r3, #0
 80003f2:	d0e5      	beq.n	80003c0 <xQueueReceive+0x10>
 80003f4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80003f8:	f383 8811 	msr	BASEPRI, r3
 80003fc:	f3bf 8f6f 	isb	sy
 8000400:	f3bf 8f4f 	dsb	sy
 8000404:	e7fe      	b.n	8000404 <xQueueReceive+0x54>
 8000406:	f04f 0800 	mov.w	r8, #0
        prvLockQueue( pxQueue );
 800040a:	2700      	movs	r7, #0
 800040c:	e03b      	b.n	8000486 <xQueueReceive+0xd6>
 800040e:	f04f 0800 	mov.w	r8, #0
 8000412:	e7fa      	b.n	800040a <xQueueReceive+0x5a>
                prvCopyDataFromQueue( pxQueue, pvBuffer );
 8000414:	4631      	mov	r1, r6
 8000416:	4620      	mov	r0, r4
 8000418:	f7ff feda 	bl	80001d0 <prvCopyDataFromQueue>
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 800041c:	3d01      	subs	r5, #1
 800041e:	63a5      	str	r5, [r4, #56]	; 0x38
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8000420:	6923      	ldr	r3, [r4, #16]
 8000422:	b92b      	cbnz	r3, 8000430 <xQueueReceive+0x80>
                taskEXIT_CRITICAL();
 8000424:	f001 f91e 	bl	8001664 <vPortExitCritical>
                return pdPASS;
 8000428:	2001      	movs	r0, #1
}
 800042a:	b004      	add	sp, #16
 800042c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8000430:	f104 0010 	add.w	r0, r4, #16
 8000434:	f000 fdb2 	bl	8000f9c <xTaskRemoveFromEventList>
 8000438:	2800      	cmp	r0, #0
 800043a:	d0f3      	beq.n	8000424 <xQueueReceive+0x74>
                        queueYIELD_IF_USING_PREEMPTION();
 800043c:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8000440:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8000444:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8000448:	f3bf 8f4f 	dsb	sy
 800044c:	f3bf 8f6f 	isb	sy
 8000450:	e7e8      	b.n	8000424 <xQueueReceive+0x74>
                    taskEXIT_CRITICAL();
 8000452:	f001 f907 	bl	8001664 <vPortExitCritical>
                    return errQUEUE_EMPTY;
 8000456:	2000      	movs	r0, #0
 8000458:	e7e7      	b.n	800042a <xQueueReceive+0x7a>
                    vTaskInternalSetTimeOutState( &xTimeOut );
 800045a:	a802      	add	r0, sp, #8
 800045c:	f000 fe14 	bl	8001088 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
 8000460:	e01c      	b.n	800049c <xQueueReceive+0xec>
                prvUnlockQueue( pxQueue );
 8000462:	4620      	mov	r0, r4
 8000464:	f7ff fec6 	bl	80001f4 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
 8000468:	f000 fbf8 	bl	8000c5c <xTaskResumeAll>
 800046c:	e009      	b.n	8000482 <xQueueReceive+0xd2>
            prvUnlockQueue( pxQueue );
 800046e:	4620      	mov	r0, r4
 8000470:	f7ff fec0 	bl	80001f4 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
 8000474:	f000 fbf2 	bl	8000c5c <xTaskResumeAll>
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8000478:	4620      	mov	r0, r4
 800047a:	f7ff fe1a 	bl	80000b2 <prvIsQueueEmpty>
 800047e:	2800      	cmp	r0, #0
 8000480:	d146      	bne.n	8000510 <xQueueReceive+0x160>
 8000482:	f04f 0801 	mov.w	r8, #1
        taskENTER_CRITICAL();
 8000486:	f001 f8cb 	bl	8001620 <vPortEnterCritical>
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 800048a:	6ba5      	ldr	r5, [r4, #56]	; 0x38
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 800048c:	2d00      	cmp	r5, #0
 800048e:	d1c1      	bne.n	8000414 <xQueueReceive+0x64>
                if( xTicksToWait == ( TickType_t ) 0 )
 8000490:	9b01      	ldr	r3, [sp, #4]
 8000492:	2b00      	cmp	r3, #0
 8000494:	d0dd      	beq.n	8000452 <xQueueReceive+0xa2>
                else if( xEntryTimeSet == pdFALSE )
 8000496:	f1b8 0f00 	cmp.w	r8, #0
 800049a:	d0de      	beq.n	800045a <xQueueReceive+0xaa>
        taskEXIT_CRITICAL();
 800049c:	f001 f8e2 	bl	8001664 <vPortExitCritical>
        vTaskSuspendAll();
 80004a0:	f000 faf4 	bl	8000a8c <vTaskSuspendAll>
        prvLockQueue( pxQueue );
 80004a4:	f001 f8bc 	bl	8001620 <vPortEnterCritical>
 80004a8:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 80004ac:	b25b      	sxtb	r3, r3
 80004ae:	f1b3 3fff 	cmp.w	r3, #4294967295
 80004b2:	bf08      	it	eq
 80004b4:	f884 7044 	strbeq.w	r7, [r4, #68]	; 0x44
 80004b8:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 80004bc:	b25b      	sxtb	r3, r3
 80004be:	f1b3 3fff 	cmp.w	r3, #4294967295
 80004c2:	bf08      	it	eq
 80004c4:	f884 7045 	strbeq.w	r7, [r4, #69]	; 0x45
 80004c8:	f001 f8cc 	bl	8001664 <vPortExitCritical>
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 80004cc:	a901      	add	r1, sp, #4
 80004ce:	a802      	add	r0, sp, #8
 80004d0:	f000 fde6 	bl	80010a0 <xTaskCheckForTimeOut>
 80004d4:	2800      	cmp	r0, #0
 80004d6:	d1ca      	bne.n	800046e <xQueueReceive+0xbe>
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 80004d8:	4620      	mov	r0, r4
 80004da:	f7ff fdea 	bl	80000b2 <prvIsQueueEmpty>
 80004de:	2800      	cmp	r0, #0
 80004e0:	d0bf      	beq.n	8000462 <xQueueReceive+0xb2>
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 80004e2:	9901      	ldr	r1, [sp, #4]
 80004e4:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80004e8:	f000 fd16 	bl	8000f18 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
 80004ec:	4620      	mov	r0, r4
 80004ee:	f7ff fe81 	bl	80001f4 <prvUnlockQueue>
                if( xTaskResumeAll() == pdFALSE )
 80004f2:	f000 fbb3 	bl	8000c5c <xTaskResumeAll>
 80004f6:	2800      	cmp	r0, #0
 80004f8:	d1c3      	bne.n	8000482 <xQueueReceive+0xd2>
                    portYIELD_WITHIN_API();
 80004fa:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80004fe:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8000502:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8000506:	f3bf 8f4f 	dsb	sy
 800050a:	f3bf 8f6f 	isb	sy
 800050e:	e7b8      	b.n	8000482 <xQueueReceive+0xd2>
                return errQUEUE_EMPTY;
 8000510:	2000      	movs	r0, #0
 8000512:	e78a      	b.n	800042a <xQueueReceive+0x7a>

08000514 <vQueueAddToRegistry>:
        configASSERT( xQueue );
 8000514:	b130      	cbz	r0, 8000524 <vQueueAddToRegistry+0x10>
    {
 8000516:	b430      	push	{r4, r5}
 8000518:	4604      	mov	r4, r0
        if( pcQueueName != NULL )
 800051a:	b309      	cbz	r1, 8000560 <vQueueAddToRegistry+0x4c>
 800051c:	4b11      	ldr	r3, [pc, #68]	; (8000564 <vQueueAddToRegistry+0x50>)
        QueueRegistryItem_t * pxEntryToWrite = NULL;
 800051e:	2000      	movs	r0, #0
            for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8000520:	4602      	mov	r2, r0
 8000522:	e010      	b.n	8000546 <vQueueAddToRegistry+0x32>
 8000524:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000528:	f383 8811 	msr	BASEPRI, r3
 800052c:	f3bf 8f6f 	isb	sy
 8000530:	f3bf 8f4f 	dsb	sy
        configASSERT( xQueue );
 8000534:	e7fe      	b.n	8000534 <vQueueAddToRegistry+0x20>
                    pxEntryToWrite = &( xQueueRegistry[ ux ] );
 8000536:	480b      	ldr	r0, [pc, #44]	; (8000564 <vQueueAddToRegistry+0x50>)
 8000538:	eb00 00c2 	add.w	r0, r0, r2, lsl #3
        if( pxEntryToWrite != NULL )
 800053c:	e00e      	b.n	800055c <vQueueAddToRegistry+0x48>
            for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 800053e:	3201      	adds	r2, #1
 8000540:	3308      	adds	r3, #8
 8000542:	2a05      	cmp	r2, #5
 8000544:	d009      	beq.n	800055a <vQueueAddToRegistry+0x46>
                if( xQueue == xQueueRegistry[ ux ].xHandle )
 8000546:	685d      	ldr	r5, [r3, #4]
 8000548:	42a5      	cmp	r5, r4
 800054a:	d0f4      	beq.n	8000536 <vQueueAddToRegistry+0x22>
                else if( ( pxEntryToWrite == NULL ) && ( xQueueRegistry[ ux ].pcQueueName == NULL ) )
 800054c:	2800      	cmp	r0, #0
 800054e:	d1f6      	bne.n	800053e <vQueueAddToRegistry+0x2a>
                    pxEntryToWrite = &( xQueueRegistry[ ux ] );
 8000550:	681d      	ldr	r5, [r3, #0]
 8000552:	2d00      	cmp	r5, #0
 8000554:	bf08      	it	eq
 8000556:	4618      	moveq	r0, r3
 8000558:	e7f1      	b.n	800053e <vQueueAddToRegistry+0x2a>
        if( pxEntryToWrite != NULL )
 800055a:	b108      	cbz	r0, 8000560 <vQueueAddToRegistry+0x4c>
            pxEntryToWrite->pcQueueName = pcQueueName;
 800055c:	6001      	str	r1, [r0, #0]
            pxEntryToWrite->xHandle = xQueue;
 800055e:	6044      	str	r4, [r0, #4]
    }
 8000560:	bc30      	pop	{r4, r5}
 8000562:	4770      	bx	lr
 8000564:	20000028 	.word	0x20000028

08000568 <vQueueWaitForMessageRestricted>:
    {
 8000568:	b570      	push	{r4, r5, r6, lr}
 800056a:	4604      	mov	r4, r0
 800056c:	460d      	mov	r5, r1
 800056e:	4616      	mov	r6, r2
        prvLockQueue( pxQueue );
 8000570:	f001 f856 	bl	8001620 <vPortEnterCritical>
 8000574:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8000578:	b25b      	sxtb	r3, r3
 800057a:	f1b3 3fff 	cmp.w	r3, #4294967295
 800057e:	bf04      	itt	eq
 8000580:	2300      	moveq	r3, #0
 8000582:	f884 3044 	strbeq.w	r3, [r4, #68]	; 0x44
 8000586:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 800058a:	b25b      	sxtb	r3, r3
 800058c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8000590:	bf04      	itt	eq
 8000592:	2300      	moveq	r3, #0
 8000594:	f884 3045 	strbeq.w	r3, [r4, #69]	; 0x45
 8000598:	f001 f864 	bl	8001664 <vPortExitCritical>
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 800059c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800059e:	b11b      	cbz	r3, 80005a8 <vQueueWaitForMessageRestricted+0x40>
        prvUnlockQueue( pxQueue );
 80005a0:	4620      	mov	r0, r4
 80005a2:	f7ff fe27 	bl	80001f4 <prvUnlockQueue>
    }
 80005a6:	bd70      	pop	{r4, r5, r6, pc}
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
 80005a8:	4632      	mov	r2, r6
 80005aa:	4629      	mov	r1, r5
 80005ac:	f104 0024 	add.w	r0, r4, #36	; 0x24
 80005b0:	f000 fcca 	bl	8000f48 <vTaskPlaceOnEventListRestricted>
 80005b4:	e7f4      	b.n	80005a0 <vQueueWaitForMessageRestricted+0x38>
	...

080005b8 <prvResetNextTaskUnblockTime>:
#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80005b8:	4b07      	ldr	r3, [pc, #28]	; (80005d8 <prvResetNextTaskUnblockTime+0x20>)
 80005ba:	681b      	ldr	r3, [r3, #0]
 80005bc:	681b      	ldr	r3, [r3, #0]
 80005be:	b923      	cbnz	r3, 80005ca <prvResetNextTaskUnblockTime+0x12>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
 80005c0:	4b06      	ldr	r3, [pc, #24]	; (80005dc <prvResetNextTaskUnblockTime+0x24>)
 80005c2:	f04f 32ff 	mov.w	r2, #4294967295
 80005c6:	601a      	str	r2, [r3, #0]
 80005c8:	4770      	bx	lr
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
 80005ca:	4b03      	ldr	r3, [pc, #12]	; (80005d8 <prvResetNextTaskUnblockTime+0x20>)
 80005cc:	681b      	ldr	r3, [r3, #0]
 80005ce:	68db      	ldr	r3, [r3, #12]
 80005d0:	681a      	ldr	r2, [r3, #0]
 80005d2:	4b02      	ldr	r3, [pc, #8]	; (80005dc <prvResetNextTaskUnblockTime+0x24>)
 80005d4:	601a      	str	r2, [r3, #0]
    }
}
 80005d6:	4770      	bx	lr
 80005d8:	20000054 	.word	0x20000054
 80005dc:	20000108 	.word	0x20000108

080005e0 <prvInitialiseNewTask>:
{
 80005e0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80005e4:	4607      	mov	r7, r0
 80005e6:	468a      	mov	sl, r1
 80005e8:	4698      	mov	r8, r3
 80005ea:	9e08      	ldr	r6, [sp, #32]
 80005ec:	9c0a      	ldr	r4, [sp, #40]	; 0x28
            ( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 80005ee:	0095      	lsls	r5, r2, #2
 80005f0:	462a      	mov	r2, r5
 80005f2:	21a5      	movs	r1, #165	; 0xa5
 80005f4:	6b20      	ldr	r0, [r4, #48]	; 0x30
 80005f6:	f001 fc5d 	bl	8001eb4 <memset>
            pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 80005fa:	f8d4 9030 	ldr.w	r9, [r4, #48]	; 0x30
    if( pcName != NULL )
 80005fe:	f1ba 0f00 	cmp.w	sl, #0
 8000602:	d01a      	beq.n	800063a <prvInitialiseNewTask+0x5a>
 8000604:	f10a 32ff 	add.w	r2, sl, #4294967295
 8000608:	f104 0333 	add.w	r3, r4, #51	; 0x33
 800060c:	f10a 0a09 	add.w	sl, sl, #9
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8000610:	f812 1f01 	ldrb.w	r1, [r2, #1]!
 8000614:	f803 1f01 	strb.w	r1, [r3, #1]!
            if( pcName[ x ] == ( char ) 0x00 )
 8000618:	b109      	cbz	r1, 800061e <prvInitialiseNewTask+0x3e>
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 800061a:	4552      	cmp	r2, sl
 800061c:	d1f8      	bne.n	8000610 <prvInitialiseNewTask+0x30>
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 800061e:	2300      	movs	r3, #0
 8000620:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
    configASSERT( uxPriority < configMAX_PRIORITIES );
 8000624:	2e04      	cmp	r6, #4
 8000626:	d90c      	bls.n	8000642 <prvInitialiseNewTask+0x62>
 8000628:	f04f 0350 	mov.w	r3, #80	; 0x50
 800062c:	f383 8811 	msr	BASEPRI, r3
 8000630:	f3bf 8f6f 	isb	sy
 8000634:	f3bf 8f4f 	dsb	sy
 8000638:	e7fe      	b.n	8000638 <prvInitialiseNewTask+0x58>
        pxNewTCB->pcTaskName[ 0 ] = 0x00;
 800063a:	2300      	movs	r3, #0
 800063c:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 8000640:	e7f0      	b.n	8000624 <prvInitialiseNewTask+0x44>
    pxNewTCB->uxPriority = uxPriority;
 8000642:	62e6      	str	r6, [r4, #44]	; 0x2c
            pxNewTCB->uxBasePriority = uxPriority;
 8000644:	64a6      	str	r6, [r4, #72]	; 0x48
            pxNewTCB->uxMutexesHeld = 0;
 8000646:	f04f 0a00 	mov.w	sl, #0
 800064a:	f8c4 a04c 	str.w	sl, [r4, #76]	; 0x4c
    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 800064e:	1d20      	adds	r0, r4, #4
 8000650:	f7ff fd01 	bl	8000056 <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 8000654:	f104 0018 	add.w	r0, r4, #24
 8000658:	f7ff fcfd 	bl	8000056 <vListInitialiseItem>
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 800065c:	6124      	str	r4, [r4, #16]
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800065e:	f1c6 0605 	rsb	r6, r6, #5
 8000662:	61a6      	str	r6, [r4, #24]
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 8000664:	6264      	str	r4, [r4, #36]	; 0x24
            pxNewTCB->pxTaskTag = NULL;
 8000666:	f8c4 a050 	str.w	sl, [r4, #80]	; 0x50
            pxNewTCB->ulRunTimeCounter = ( configRUN_TIME_COUNTER_TYPE ) 0;
 800066a:	f8c4 a05c 	str.w	sl, [r4, #92]	; 0x5c
            memset( ( void * ) &( pxNewTCB->pvThreadLocalStoragePointers[ 0 ] ), 0x00, sizeof( pxNewTCB->pvThreadLocalStoragePointers ) );
 800066e:	f8c4 a054 	str.w	sl, [r4, #84]	; 0x54
 8000672:	f8c4 a058 	str.w	sl, [r4, #88]	; 0x58
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
 8000676:	f8c4 a060 	str.w	sl, [r4, #96]	; 0x60
            memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyState ) );
 800067a:	f884 a064 	strb.w	sl, [r4, #100]	; 0x64
            pxNewTCB->ucDelayAborted = pdFALSE;
 800067e:	f884 a066 	strb.w	sl, [r4, #102]	; 0x66
            pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 8000682:	3d04      	subs	r5, #4
 8000684:	444d      	add	r5, r9
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8000686:	4642      	mov	r2, r8
 8000688:	4639      	mov	r1, r7
 800068a:	f025 0007 	bic.w	r0, r5, #7
 800068e:	f000 ffb1 	bl	80015f4 <pxPortInitialiseStack>
 8000692:	6020      	str	r0, [r4, #0]
    if( pxCreatedTask != NULL )
 8000694:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8000696:	b103      	cbz	r3, 800069a <prvInitialiseNewTask+0xba>
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8000698:	601c      	str	r4, [r3, #0]
}
 800069a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	...

080006a0 <prvAddNewTaskToReadyList>:
{
 80006a0:	b570      	push	{r4, r5, r6, lr}
 80006a2:	4604      	mov	r4, r0
    taskENTER_CRITICAL();
 80006a4:	f000 ffbc 	bl	8001620 <vPortEnterCritical>
        uxCurrentNumberOfTasks++;
 80006a8:	4a37      	ldr	r2, [pc, #220]	; (8000788 <prvAddNewTaskToReadyList+0xe8>)
 80006aa:	6813      	ldr	r3, [r2, #0]
 80006ac:	3301      	adds	r3, #1
 80006ae:	6013      	str	r3, [r2, #0]
        if( pxCurrentTCB == NULL )
 80006b0:	4b36      	ldr	r3, [pc, #216]	; (800078c <prvAddNewTaskToReadyList+0xec>)
 80006b2:	681b      	ldr	r3, [r3, #0]
 80006b4:	2b00      	cmp	r3, #0
 80006b6:	d042      	beq.n	800073e <prvAddNewTaskToReadyList+0x9e>
            if( xSchedulerRunning == pdFALSE )
 80006b8:	4b35      	ldr	r3, [pc, #212]	; (8000790 <prvAddNewTaskToReadyList+0xf0>)
 80006ba:	681b      	ldr	r3, [r3, #0]
 80006bc:	b93b      	cbnz	r3, 80006ce <prvAddNewTaskToReadyList+0x2e>
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 80006be:	4b33      	ldr	r3, [pc, #204]	; (800078c <prvAddNewTaskToReadyList+0xec>)
 80006c0:	681b      	ldr	r3, [r3, #0]
 80006c2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80006c4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80006c6:	429a      	cmp	r2, r3
                    pxCurrentTCB = pxNewTCB;
 80006c8:	bf9c      	itt	ls
 80006ca:	4b30      	ldrls	r3, [pc, #192]	; (800078c <prvAddNewTaskToReadyList+0xec>)
 80006cc:	601c      	strls	r4, [r3, #0]
        uxTaskNumber++;
 80006ce:	4a31      	ldr	r2, [pc, #196]	; (8000794 <prvAddNewTaskToReadyList+0xf4>)
 80006d0:	6813      	ldr	r3, [r2, #0]
 80006d2:	3301      	adds	r3, #1
 80006d4:	6013      	str	r3, [r2, #0]
                pxNewTCB->uxTCBNumber = uxTaskNumber;
 80006d6:	6423      	str	r3, [r4, #64]	; 0x40
        prvAddTaskToReadyList( pxNewTCB );
 80006d8:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80006da:	492f      	ldr	r1, [pc, #188]	; (8000798 <prvAddNewTaskToReadyList+0xf8>)
 80006dc:	6808      	ldr	r0, [r1, #0]
 80006de:	2201      	movs	r2, #1
 80006e0:	409a      	lsls	r2, r3
 80006e2:	4302      	orrs	r2, r0
 80006e4:	600a      	str	r2, [r1, #0]
 80006e6:	4a2d      	ldr	r2, [pc, #180]	; (800079c <prvAddNewTaskToReadyList+0xfc>)
 80006e8:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80006ec:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 80006f0:	685b      	ldr	r3, [r3, #4]
 80006f2:	60a3      	str	r3, [r4, #8]
 80006f4:	6898      	ldr	r0, [r3, #8]
 80006f6:	60e0      	str	r0, [r4, #12]
 80006f8:	1d21      	adds	r1, r4, #4
 80006fa:	6041      	str	r1, [r0, #4]
 80006fc:	6099      	str	r1, [r3, #8]
 80006fe:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8000700:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 8000704:	0088      	lsls	r0, r1, #2
 8000706:	eb02 0181 	add.w	r1, r2, r1, lsl #2
 800070a:	6161      	str	r1, [r4, #20]
 800070c:	5811      	ldr	r1, [r2, r0]
 800070e:	3101      	adds	r1, #1
 8000710:	5011      	str	r1, [r2, r0]
    taskEXIT_CRITICAL();
 8000712:	f000 ffa7 	bl	8001664 <vPortExitCritical>
    if( xSchedulerRunning != pdFALSE )
 8000716:	4b1e      	ldr	r3, [pc, #120]	; (8000790 <prvAddNewTaskToReadyList+0xf0>)
 8000718:	681b      	ldr	r3, [r3, #0]
 800071a:	b17b      	cbz	r3, 800073c <prvAddNewTaskToReadyList+0x9c>
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 800071c:	4b1b      	ldr	r3, [pc, #108]	; (800078c <prvAddNewTaskToReadyList+0xec>)
 800071e:	681b      	ldr	r3, [r3, #0]
 8000720:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8000722:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8000724:	429a      	cmp	r2, r3
 8000726:	d209      	bcs.n	800073c <prvAddNewTaskToReadyList+0x9c>
            taskYIELD_IF_USING_PREEMPTION();
 8000728:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800072c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8000730:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8000734:	f3bf 8f4f 	dsb	sy
 8000738:	f3bf 8f6f 	isb	sy
}
 800073c:	bd70      	pop	{r4, r5, r6, pc}
            pxCurrentTCB = pxNewTCB;
 800073e:	4b13      	ldr	r3, [pc, #76]	; (800078c <prvAddNewTaskToReadyList+0xec>)
 8000740:	601c      	str	r4, [r3, #0]
            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 8000742:	6813      	ldr	r3, [r2, #0]
 8000744:	2b01      	cmp	r3, #1
 8000746:	d1c2      	bne.n	80006ce <prvAddNewTaskToReadyList+0x2e>
 8000748:	4d14      	ldr	r5, [pc, #80]	; (800079c <prvAddNewTaskToReadyList+0xfc>)
 800074a:	f105 0664 	add.w	r6, r5, #100	; 0x64
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 800074e:	4628      	mov	r0, r5
 8000750:	f7ff fc76 	bl	8000040 <vListInitialise>
    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8000754:	3514      	adds	r5, #20
 8000756:	42b5      	cmp	r5, r6
 8000758:	d1f9      	bne.n	800074e <prvAddNewTaskToReadyList+0xae>
    vListInitialise( &xDelayedTaskList1 );
 800075a:	4e11      	ldr	r6, [pc, #68]	; (80007a0 <prvAddNewTaskToReadyList+0x100>)
 800075c:	4630      	mov	r0, r6
 800075e:	f7ff fc6f 	bl	8000040 <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
 8000762:	4d10      	ldr	r5, [pc, #64]	; (80007a4 <prvAddNewTaskToReadyList+0x104>)
 8000764:	4628      	mov	r0, r5
 8000766:	f7ff fc6b 	bl	8000040 <vListInitialise>
    vListInitialise( &xPendingReadyList );
 800076a:	480f      	ldr	r0, [pc, #60]	; (80007a8 <prvAddNewTaskToReadyList+0x108>)
 800076c:	f7ff fc68 	bl	8000040 <vListInitialise>
            vListInitialise( &xTasksWaitingTermination );
 8000770:	480e      	ldr	r0, [pc, #56]	; (80007ac <prvAddNewTaskToReadyList+0x10c>)
 8000772:	f7ff fc65 	bl	8000040 <vListInitialise>
            vListInitialise( &xSuspendedTaskList );
 8000776:	480e      	ldr	r0, [pc, #56]	; (80007b0 <prvAddNewTaskToReadyList+0x110>)
 8000778:	f7ff fc62 	bl	8000040 <vListInitialise>
    pxDelayedTaskList = &xDelayedTaskList1;
 800077c:	4b0d      	ldr	r3, [pc, #52]	; (80007b4 <prvAddNewTaskToReadyList+0x114>)
 800077e:	601e      	str	r6, [r3, #0]
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8000780:	4b0d      	ldr	r3, [pc, #52]	; (80007b8 <prvAddNewTaskToReadyList+0x118>)
 8000782:	601d      	str	r5, [r3, #0]
}
 8000784:	e7a3      	b.n	80006ce <prvAddNewTaskToReadyList+0x2e>
 8000786:	bf00      	nop
 8000788:	200000c8 	.word	0x200000c8
 800078c:	20000050 	.word	0x20000050
 8000790:	20000128 	.word	0x20000128
 8000794:	200000d4 	.word	0x200000d4
 8000798:	200000d8 	.word	0x200000d8
 800079c:	2000005c 	.word	0x2000005c
 80007a0:	200000dc 	.word	0x200000dc
 80007a4:	200000f0 	.word	0x200000f0
 80007a8:	20000114 	.word	0x20000114
 80007ac:	20000140 	.word	0x20000140
 80007b0:	2000012c 	.word	0x2000012c
 80007b4:	20000054 	.word	0x20000054
 80007b8:	20000058 	.word	0x20000058

080007bc <prvDeleteTCB>:
    {
 80007bc:	b510      	push	{r4, lr}
 80007be:	4604      	mov	r4, r0
                if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
 80007c0:	f890 3065 	ldrb.w	r3, [r0, #101]	; 0x65
 80007c4:	b163      	cbz	r3, 80007e0 <prvDeleteTCB+0x24>
                else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
 80007c6:	2b01      	cmp	r3, #1
 80007c8:	d011      	beq.n	80007ee <prvDeleteTCB+0x32>
                    configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
 80007ca:	2b02      	cmp	r3, #2
 80007cc:	d00e      	beq.n	80007ec <prvDeleteTCB+0x30>
 80007ce:	f04f 0350 	mov.w	r3, #80	; 0x50
 80007d2:	f383 8811 	msr	BASEPRI, r3
 80007d6:	f3bf 8f6f 	isb	sy
 80007da:	f3bf 8f4f 	dsb	sy
 80007de:	e7fe      	b.n	80007de <prvDeleteTCB+0x22>
                    vPortFreeStack( pxTCB->pxStack );
 80007e0:	6b00      	ldr	r0, [r0, #48]	; 0x30
 80007e2:	f001 f8bf 	bl	8001964 <vPortFree>
                    vPortFree( pxTCB );
 80007e6:	4620      	mov	r0, r4
 80007e8:	f001 f8bc 	bl	8001964 <vPortFree>
    }
 80007ec:	bd10      	pop	{r4, pc}
                    vPortFree( pxTCB );
 80007ee:	f001 f8b9 	bl	8001964 <vPortFree>
 80007f2:	e7fb      	b.n	80007ec <prvDeleteTCB+0x30>

080007f4 <prvIdleTask>:
{
 80007f4:	b580      	push	{r7, lr}
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 80007f6:	4c15      	ldr	r4, [pc, #84]	; (800084c <prvIdleTask+0x58>)
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80007f8:	4f15      	ldr	r7, [pc, #84]	; (8000850 <prvIdleTask+0x5c>)
                    --uxCurrentNumberOfTasks;
 80007fa:	4e16      	ldr	r6, [pc, #88]	; (8000854 <prvIdleTask+0x60>)
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 80007fc:	f8df 8058 	ldr.w	r8, [pc, #88]	; 8000858 <prvIdleTask+0x64>
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8000800:	6823      	ldr	r3, [r4, #0]
 8000802:	b1a3      	cbz	r3, 800082e <prvIdleTask+0x3a>
                taskENTER_CRITICAL();
 8000804:	f000 ff0c 	bl	8001620 <vPortEnterCritical>
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8000808:	68fb      	ldr	r3, [r7, #12]
 800080a:	68dd      	ldr	r5, [r3, #12]
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800080c:	1d28      	adds	r0, r5, #4
 800080e:	f7ff fc3e 	bl	800008e <uxListRemove>
                    --uxCurrentNumberOfTasks;
 8000812:	6833      	ldr	r3, [r6, #0]
 8000814:	3b01      	subs	r3, #1
 8000816:	6033      	str	r3, [r6, #0]
                    --uxDeletedTasksWaitingCleanUp;
 8000818:	6823      	ldr	r3, [r4, #0]
 800081a:	3b01      	subs	r3, #1
 800081c:	6023      	str	r3, [r4, #0]
                taskEXIT_CRITICAL();
 800081e:	f000 ff21 	bl	8001664 <vPortExitCritical>
                prvDeleteTCB( pxTCB );
 8000822:	4628      	mov	r0, r5
 8000824:	f7ff ffca 	bl	80007bc <prvDeleteTCB>
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8000828:	6823      	ldr	r3, [r4, #0]
 800082a:	2b00      	cmp	r3, #0
 800082c:	d1ea      	bne.n	8000804 <prvIdleTask+0x10>
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 800082e:	f8d8 3000 	ldr.w	r3, [r8]
 8000832:	2b01      	cmp	r3, #1
 8000834:	d9e4      	bls.n	8000800 <prvIdleTask+0xc>
                    taskYIELD();
 8000836:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800083a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800083e:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8000842:	f3bf 8f4f 	dsb	sy
 8000846:	f3bf 8f6f 	isb	sy
 800084a:	e7d9      	b.n	8000800 <prvIdleTask+0xc>
 800084c:	200000cc 	.word	0x200000cc
 8000850:	20000140 	.word	0x20000140
 8000854:	200000c8 	.word	0x200000c8
 8000858:	2000005c 	.word	0x2000005c

0800085c <prvAddCurrentTaskToDelayedList>:
#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
 800085c:	b570      	push	{r4, r5, r6, lr}
 800085e:	4604      	mov	r4, r0
 8000860:	460d      	mov	r5, r1
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
 8000862:	4b25      	ldr	r3, [pc, #148]	; (80008f8 <prvAddCurrentTaskToDelayedList+0x9c>)
 8000864:	681e      	ldr	r6, [r3, #0]
    #if ( INCLUDE_xTaskAbortDelay == 1 )
        {
            /* About to enter a delayed list, so ensure the ucDelayAborted flag is
             * reset to pdFALSE so it can be detected as having been set to pdTRUE
             * when the task leaves the Blocked state. */
            pxCurrentTCB->ucDelayAborted = pdFALSE;
 8000866:	4b25      	ldr	r3, [pc, #148]	; (80008fc <prvAddCurrentTaskToDelayedList+0xa0>)
 8000868:	681a      	ldr	r2, [r3, #0]
 800086a:	2100      	movs	r1, #0
 800086c:	f882 1066 	strb.w	r1, [r2, #102]	; 0x66
        }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8000870:	6818      	ldr	r0, [r3, #0]
 8000872:	3004      	adds	r0, #4
 8000874:	f7ff fc0b 	bl	800008e <uxListRemove>
 8000878:	b948      	cbnz	r0, 800088e <prvAddCurrentTaskToDelayedList+0x32>
    {
        /* The current task must be in a ready list, so there is no need to
         * check, and the port reset macro can be called directly. */
        portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); /*lint !e931 pxCurrentTCB cannot change as it is the calling task.  pxCurrentTCB->uxPriority and uxTopReadyPriority cannot change as called with scheduler suspended or in a critical section. */
 800087a:	4b20      	ldr	r3, [pc, #128]	; (80008fc <prvAddCurrentTaskToDelayedList+0xa0>)
 800087c:	681a      	ldr	r2, [r3, #0]
 800087e:	4920      	ldr	r1, [pc, #128]	; (8000900 <prvAddCurrentTaskToDelayedList+0xa4>)
 8000880:	680b      	ldr	r3, [r1, #0]
 8000882:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
 8000884:	2201      	movs	r2, #1
 8000886:	4082      	lsls	r2, r0
 8000888:	ea23 0302 	bic.w	r3, r3, r2
 800088c:	600b      	str	r3, [r1, #0]
        mtCOVERAGE_TEST_MARKER();
    }

    #if ( INCLUDE_vTaskSuspend == 1 )
        {
            if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 800088e:	f1b4 3fff 	cmp.w	r4, #4294967295
 8000892:	d00d      	beq.n	80008b0 <prvAddCurrentTaskToDelayedList+0x54>
            else
            {
                /* Calculate the time at which the task should be woken if the event
                 * does not occur.  This may overflow but this doesn't matter, the
                 * kernel will manage it correctly. */
                xTimeToWake = xConstTickCount + xTicksToWait;
 8000894:	4434      	add	r4, r6

                /* The list item will be inserted in wake time order. */
                listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8000896:	4b19      	ldr	r3, [pc, #100]	; (80008fc <prvAddCurrentTaskToDelayedList+0xa0>)
 8000898:	681b      	ldr	r3, [r3, #0]
 800089a:	605c      	str	r4, [r3, #4]

                if( xTimeToWake < xConstTickCount )
 800089c:	42a6      	cmp	r6, r4
 800089e:	d91d      	bls.n	80008dc <prvAddCurrentTaskToDelayedList+0x80>
                {
                    /* Wake time has overflowed.  Place this item in the overflow
                     * list. */
                    vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80008a0:	4b18      	ldr	r3, [pc, #96]	; (8000904 <prvAddCurrentTaskToDelayedList+0xa8>)
 80008a2:	6818      	ldr	r0, [r3, #0]
 80008a4:	4b15      	ldr	r3, [pc, #84]	; (80008fc <prvAddCurrentTaskToDelayedList+0xa0>)
 80008a6:	6819      	ldr	r1, [r3, #0]
 80008a8:	3104      	adds	r1, #4
 80008aa:	f7ff fbd7 	bl	800005c <vListInsert>

            /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
            ( void ) xCanBlockIndefinitely;
        }
    #endif /* INCLUDE_vTaskSuspend */
}
 80008ae:	bd70      	pop	{r4, r5, r6, pc}
            if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 80008b0:	2d00      	cmp	r5, #0
 80008b2:	d0ef      	beq.n	8000894 <prvAddCurrentTaskToDelayedList+0x38>
                listINSERT_END( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80008b4:	4a14      	ldr	r2, [pc, #80]	; (8000908 <prvAddCurrentTaskToDelayedList+0xac>)
 80008b6:	6851      	ldr	r1, [r2, #4]
 80008b8:	4b10      	ldr	r3, [pc, #64]	; (80008fc <prvAddCurrentTaskToDelayedList+0xa0>)
 80008ba:	6818      	ldr	r0, [r3, #0]
 80008bc:	6081      	str	r1, [r0, #8]
 80008be:	6818      	ldr	r0, [r3, #0]
 80008c0:	688c      	ldr	r4, [r1, #8]
 80008c2:	60c4      	str	r4, [r0, #12]
 80008c4:	6818      	ldr	r0, [r3, #0]
 80008c6:	3004      	adds	r0, #4
 80008c8:	6060      	str	r0, [r4, #4]
 80008ca:	6818      	ldr	r0, [r3, #0]
 80008cc:	3004      	adds	r0, #4
 80008ce:	6088      	str	r0, [r1, #8]
 80008d0:	681b      	ldr	r3, [r3, #0]
 80008d2:	615a      	str	r2, [r3, #20]
 80008d4:	6813      	ldr	r3, [r2, #0]
 80008d6:	3301      	adds	r3, #1
 80008d8:	6013      	str	r3, [r2, #0]
 80008da:	e7e8      	b.n	80008ae <prvAddCurrentTaskToDelayedList+0x52>
                    vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80008dc:	4b0b      	ldr	r3, [pc, #44]	; (800090c <prvAddCurrentTaskToDelayedList+0xb0>)
 80008de:	6818      	ldr	r0, [r3, #0]
 80008e0:	4b06      	ldr	r3, [pc, #24]	; (80008fc <prvAddCurrentTaskToDelayedList+0xa0>)
 80008e2:	6819      	ldr	r1, [r3, #0]
 80008e4:	3104      	adds	r1, #4
 80008e6:	f7ff fbb9 	bl	800005c <vListInsert>
                    if( xTimeToWake < xNextTaskUnblockTime )
 80008ea:	4b09      	ldr	r3, [pc, #36]	; (8000910 <prvAddCurrentTaskToDelayedList+0xb4>)
 80008ec:	681b      	ldr	r3, [r3, #0]
 80008ee:	42a3      	cmp	r3, r4
                        xNextTaskUnblockTime = xTimeToWake;
 80008f0:	bf84      	itt	hi
 80008f2:	4b07      	ldrhi	r3, [pc, #28]	; (8000910 <prvAddCurrentTaskToDelayedList+0xb4>)
 80008f4:	601c      	strhi	r4, [r3, #0]
}
 80008f6:	e7da      	b.n	80008ae <prvAddCurrentTaskToDelayedList+0x52>
 80008f8:	20000154 	.word	0x20000154
 80008fc:	20000050 	.word	0x20000050
 8000900:	200000d8 	.word	0x200000d8
 8000904:	20000058 	.word	0x20000058
 8000908:	2000012c 	.word	0x2000012c
 800090c:	20000054 	.word	0x20000054
 8000910:	20000108 	.word	0x20000108

08000914 <xTaskCreateStatic>:
    {
 8000914:	b530      	push	{r4, r5, lr}
 8000916:	b087      	sub	sp, #28
 8000918:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
        configASSERT( puxStackBuffer != NULL );
 800091a:	b17c      	cbz	r4, 800093c <xTaskCreateStatic+0x28>
        configASSERT( pxTaskBuffer != NULL );
 800091c:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 800091e:	b1b5      	cbz	r5, 800094e <xTaskCreateStatic+0x3a>
                volatile size_t xSize = sizeof( StaticTask_t );
 8000920:	2568      	movs	r5, #104	; 0x68
 8000922:	9504      	str	r5, [sp, #16]
                configASSERT( xSize == sizeof( TCB_t ) );
 8000924:	9d04      	ldr	r5, [sp, #16]
 8000926:	2d68      	cmp	r5, #104	; 0x68
 8000928:	d01a      	beq.n	8000960 <xTaskCreateStatic+0x4c>
 800092a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800092e:	f383 8811 	msr	BASEPRI, r3
 8000932:	f3bf 8f6f 	isb	sy
 8000936:	f3bf 8f4f 	dsb	sy
 800093a:	e7fe      	b.n	800093a <xTaskCreateStatic+0x26>
 800093c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000940:	f383 8811 	msr	BASEPRI, r3
 8000944:	f3bf 8f6f 	isb	sy
 8000948:	f3bf 8f4f 	dsb	sy
        configASSERT( puxStackBuffer != NULL );
 800094c:	e7fe      	b.n	800094c <xTaskCreateStatic+0x38>
 800094e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000952:	f383 8811 	msr	BASEPRI, r3
 8000956:	f3bf 8f6f 	isb	sy
 800095a:	f3bf 8f4f 	dsb	sy
        configASSERT( pxTaskBuffer != NULL );
 800095e:	e7fe      	b.n	800095e <xTaskCreateStatic+0x4a>
                ( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */
 8000960:	9d04      	ldr	r5, [sp, #16]
            pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 8000962:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8000964:	632c      	str	r4, [r5, #48]	; 0x30
                    pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 8000966:	2402      	movs	r4, #2
 8000968:	f885 4065 	strb.w	r4, [r5, #101]	; 0x65
            prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
 800096c:	2400      	movs	r4, #0
 800096e:	9403      	str	r4, [sp, #12]
 8000970:	9502      	str	r5, [sp, #8]
 8000972:	ac05      	add	r4, sp, #20
 8000974:	9401      	str	r4, [sp, #4]
 8000976:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 8000978:	9400      	str	r4, [sp, #0]
 800097a:	f7ff fe31 	bl	80005e0 <prvInitialiseNewTask>
            prvAddNewTaskToReadyList( pxNewTCB );
 800097e:	980c      	ldr	r0, [sp, #48]	; 0x30
 8000980:	f7ff fe8e 	bl	80006a0 <prvAddNewTaskToReadyList>
    }
 8000984:	9805      	ldr	r0, [sp, #20]
 8000986:	b007      	add	sp, #28
 8000988:	bd30      	pop	{r4, r5, pc}

0800098a <xTaskCreate>:
    {
 800098a:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800098e:	b085      	sub	sp, #20
 8000990:	4607      	mov	r7, r0
 8000992:	4688      	mov	r8, r1
 8000994:	4614      	mov	r4, r2
 8000996:	461e      	mov	r6, r3
                pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 8000998:	0090      	lsls	r0, r2, #2
 800099a:	f000 ff43 	bl	8001824 <pvPortMalloc>
                if( pxStack != NULL )
 800099e:	b308      	cbz	r0, 80009e4 <xTaskCreate+0x5a>
 80009a0:	4681      	mov	r9, r0
                    pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
 80009a2:	2068      	movs	r0, #104	; 0x68
 80009a4:	f000 ff3e 	bl	8001824 <pvPortMalloc>
                    if( pxNewTCB != NULL )
 80009a8:	4605      	mov	r5, r0
 80009aa:	b1a8      	cbz	r0, 80009d8 <xTaskCreate+0x4e>
                        pxNewTCB->pxStack = pxStack;
 80009ac:	f8c0 9030 	str.w	r9, [r0, #48]	; 0x30
                    pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
 80009b0:	2300      	movs	r3, #0
 80009b2:	f880 3065 	strb.w	r3, [r0, #101]	; 0x65
            prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 80009b6:	9303      	str	r3, [sp, #12]
 80009b8:	9002      	str	r0, [sp, #8]
 80009ba:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80009bc:	9301      	str	r3, [sp, #4]
 80009be:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80009c0:	9300      	str	r3, [sp, #0]
 80009c2:	4633      	mov	r3, r6
 80009c4:	4622      	mov	r2, r4
 80009c6:	4641      	mov	r1, r8
 80009c8:	4638      	mov	r0, r7
 80009ca:	f7ff fe09 	bl	80005e0 <prvInitialiseNewTask>
            prvAddNewTaskToReadyList( pxNewTCB );
 80009ce:	4628      	mov	r0, r5
 80009d0:	f7ff fe66 	bl	80006a0 <prvAddNewTaskToReadyList>
            xReturn = pdPASS;
 80009d4:	2001      	movs	r0, #1
 80009d6:	e007      	b.n	80009e8 <xTaskCreate+0x5e>
                        vPortFreeStack( pxStack );
 80009d8:	4648      	mov	r0, r9
 80009da:	f000 ffc3 	bl	8001964 <vPortFree>
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 80009de:	f04f 30ff 	mov.w	r0, #4294967295
 80009e2:	e001      	b.n	80009e8 <xTaskCreate+0x5e>
 80009e4:	f04f 30ff 	mov.w	r0, #4294967295
    }
 80009e8:	b005      	add	sp, #20
 80009ea:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	...

080009f0 <vTaskStartScheduler>:
{
 80009f0:	b510      	push	{r4, lr}
 80009f2:	b088      	sub	sp, #32
            StaticTask_t * pxIdleTaskTCBBuffer = NULL;
 80009f4:	2400      	movs	r4, #0
 80009f6:	9405      	str	r4, [sp, #20]
            StackType_t * pxIdleTaskStackBuffer = NULL;
 80009f8:	9406      	str	r4, [sp, #24]
            vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
 80009fa:	aa07      	add	r2, sp, #28
 80009fc:	a906      	add	r1, sp, #24
 80009fe:	a805      	add	r0, sp, #20
 8000a00:	f001 f860 	bl	8001ac4 <vApplicationGetIdleTaskMemory>
            xIdleTaskHandle = xTaskCreateStatic( prvIdleTask,
 8000a04:	9b05      	ldr	r3, [sp, #20]
 8000a06:	9302      	str	r3, [sp, #8]
 8000a08:	9b06      	ldr	r3, [sp, #24]
 8000a0a:	9301      	str	r3, [sp, #4]
 8000a0c:	9400      	str	r4, [sp, #0]
 8000a0e:	4623      	mov	r3, r4
 8000a10:	9a07      	ldr	r2, [sp, #28]
 8000a12:	4917      	ldr	r1, [pc, #92]	; (8000a70 <vTaskStartScheduler+0x80>)
 8000a14:	4817      	ldr	r0, [pc, #92]	; (8000a74 <vTaskStartScheduler+0x84>)
 8000a16:	f7ff ff7d 	bl	8000914 <xTaskCreateStatic>
 8000a1a:	4b17      	ldr	r3, [pc, #92]	; (8000a78 <vTaskStartScheduler+0x88>)
 8000a1c:	6018      	str	r0, [r3, #0]
            if( xIdleTaskHandle != NULL )
 8000a1e:	b310      	cbz	r0, 8000a66 <vTaskStartScheduler+0x76>
                xReturn = xTimerCreateTimerTask();
 8000a20:	f000 fd78 	bl	8001514 <xTimerCreateTimerTask>
    if( xReturn == pdPASS )
 8000a24:	2801      	cmp	r0, #1
 8000a26:	d00b      	beq.n	8000a40 <vTaskStartScheduler+0x50>
        configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 8000a28:	f1b0 3fff 	cmp.w	r0, #4294967295
 8000a2c:	d11b      	bne.n	8000a66 <vTaskStartScheduler+0x76>
 8000a2e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000a32:	f383 8811 	msr	BASEPRI, r3
 8000a36:	f3bf 8f6f 	isb	sy
 8000a3a:	f3bf 8f4f 	dsb	sy
 8000a3e:	e7fe      	b.n	8000a3e <vTaskStartScheduler+0x4e>
 8000a40:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000a44:	f383 8811 	msr	BASEPRI, r3
 8000a48:	f3bf 8f6f 	isb	sy
 8000a4c:	f3bf 8f4f 	dsb	sy
        xNextTaskUnblockTime = portMAX_DELAY;
 8000a50:	4b0a      	ldr	r3, [pc, #40]	; (8000a7c <vTaskStartScheduler+0x8c>)
 8000a52:	f04f 32ff 	mov.w	r2, #4294967295
 8000a56:	601a      	str	r2, [r3, #0]
        xSchedulerRunning = pdTRUE;
 8000a58:	4b09      	ldr	r3, [pc, #36]	; (8000a80 <vTaskStartScheduler+0x90>)
 8000a5a:	2201      	movs	r2, #1
 8000a5c:	601a      	str	r2, [r3, #0]
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 8000a5e:	4b09      	ldr	r3, [pc, #36]	; (8000a84 <vTaskStartScheduler+0x94>)
 8000a60:	601c      	str	r4, [r3, #0]
        if( xPortStartScheduler() != pdFALSE )
 8000a62:	f000 fe21 	bl	80016a8 <xPortStartScheduler>
    ( void ) uxTopUsedPriority;
 8000a66:	4b08      	ldr	r3, [pc, #32]	; (8000a88 <vTaskStartScheduler+0x98>)
 8000a68:	681b      	ldr	r3, [r3, #0]
}
 8000a6a:	b008      	add	sp, #32
 8000a6c:	bd10      	pop	{r4, pc}
 8000a6e:	bf00      	nop
 8000a70:	08001edc 	.word	0x08001edc
 8000a74:	080007f5 	.word	0x080007f5
 8000a78:	20000104 	.word	0x20000104
 8000a7c:	20000108 	.word	0x20000108
 8000a80:	20000128 	.word	0x20000128
 8000a84:	20000154 	.word	0x20000154
 8000a88:	20000000 	.word	0x20000000

08000a8c <vTaskSuspendAll>:
    ++uxSchedulerSuspended;
 8000a8c:	4a02      	ldr	r2, [pc, #8]	; (8000a98 <vTaskSuspendAll+0xc>)
 8000a8e:	6813      	ldr	r3, [r2, #0]
 8000a90:	3301      	adds	r3, #1
 8000a92:	6013      	str	r3, [r2, #0]
}
 8000a94:	4770      	bx	lr
 8000a96:	bf00      	nop
 8000a98:	200000d0 	.word	0x200000d0

08000a9c <xTaskGetTickCount>:
        xTicks = xTickCount;
 8000a9c:	4b01      	ldr	r3, [pc, #4]	; (8000aa4 <xTaskGetTickCount+0x8>)
 8000a9e:	6818      	ldr	r0, [r3, #0]
}
 8000aa0:	4770      	bx	lr
 8000aa2:	bf00      	nop
 8000aa4:	20000154 	.word	0x20000154

08000aa8 <xTaskIncrementTick>:
{
 8000aa8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8000aac:	4b60      	ldr	r3, [pc, #384]	; (8000c30 <xTaskIncrementTick+0x188>)
 8000aae:	681b      	ldr	r3, [r3, #0]
 8000ab0:	2b00      	cmp	r3, #0
 8000ab2:	f040 80b6 	bne.w	8000c22 <xTaskIncrementTick+0x17a>
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 8000ab6:	4b5f      	ldr	r3, [pc, #380]	; (8000c34 <xTaskIncrementTick+0x18c>)
 8000ab8:	681c      	ldr	r4, [r3, #0]
 8000aba:	3401      	adds	r4, #1
        xTickCount = xConstTickCount;
 8000abc:	601c      	str	r4, [r3, #0]
        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 8000abe:	b9c4      	cbnz	r4, 8000af2 <xTaskIncrementTick+0x4a>
            taskSWITCH_DELAYED_LISTS();
 8000ac0:	4b5d      	ldr	r3, [pc, #372]	; (8000c38 <xTaskIncrementTick+0x190>)
 8000ac2:	681b      	ldr	r3, [r3, #0]
 8000ac4:	681b      	ldr	r3, [r3, #0]
 8000ac6:	b143      	cbz	r3, 8000ada <xTaskIncrementTick+0x32>
 8000ac8:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000acc:	f383 8811 	msr	BASEPRI, r3
 8000ad0:	f3bf 8f6f 	isb	sy
 8000ad4:	f3bf 8f4f 	dsb	sy
 8000ad8:	e7fe      	b.n	8000ad8 <xTaskIncrementTick+0x30>
 8000ada:	4a57      	ldr	r2, [pc, #348]	; (8000c38 <xTaskIncrementTick+0x190>)
 8000adc:	6811      	ldr	r1, [r2, #0]
 8000ade:	4b57      	ldr	r3, [pc, #348]	; (8000c3c <xTaskIncrementTick+0x194>)
 8000ae0:	6818      	ldr	r0, [r3, #0]
 8000ae2:	6010      	str	r0, [r2, #0]
 8000ae4:	6019      	str	r1, [r3, #0]
 8000ae6:	4a56      	ldr	r2, [pc, #344]	; (8000c40 <xTaskIncrementTick+0x198>)
 8000ae8:	6813      	ldr	r3, [r2, #0]
 8000aea:	3301      	adds	r3, #1
 8000aec:	6013      	str	r3, [r2, #0]
 8000aee:	f7ff fd63 	bl	80005b8 <prvResetNextTaskUnblockTime>
        if( xConstTickCount >= xNextTaskUnblockTime )
 8000af2:	4b54      	ldr	r3, [pc, #336]	; (8000c44 <xTaskIncrementTick+0x19c>)
 8000af4:	681b      	ldr	r3, [r3, #0]
 8000af6:	42a3      	cmp	r3, r4
 8000af8:	f200 8081 	bhi.w	8000bfe <xTaskIncrementTick+0x156>
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8000afc:	4b4e      	ldr	r3, [pc, #312]	; (8000c38 <xTaskIncrementTick+0x190>)
 8000afe:	681b      	ldr	r3, [r3, #0]
 8000b00:	681b      	ldr	r3, [r3, #0]
 8000b02:	b153      	cbz	r3, 8000b1a <xTaskIncrementTick+0x72>
    BaseType_t xSwitchRequired = pdFALSE;
 8000b04:	2000      	movs	r0, #0
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8000b06:	494c      	ldr	r1, [pc, #304]	; (8000c38 <xTaskIncrementTick+0x190>)
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 8000b08:	4605      	mov	r5, r0
                    prvAddTaskToReadyList( pxTCB );
 8000b0a:	f8df c14c 	ldr.w	ip, [pc, #332]	; 8000c58 <xTaskIncrementTick+0x1b0>
 8000b0e:	f04f 0b01 	mov.w	fp, #1
 8000b12:	4a4d      	ldr	r2, [pc, #308]	; (8000c48 <xTaskIncrementTick+0x1a0>)
                            if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8000b14:	f8df e134 	ldr.w	lr, [pc, #308]	; 8000c4c <xTaskIncrementTick+0x1a4>
 8000b18:	e03a      	b.n	8000b90 <xTaskIncrementTick+0xe8>
    BaseType_t xSwitchRequired = pdFALSE;
 8000b1a:	2000      	movs	r0, #0
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8000b1c:	4b49      	ldr	r3, [pc, #292]	; (8000c44 <xTaskIncrementTick+0x19c>)
 8000b1e:	f04f 32ff 	mov.w	r2, #4294967295
 8000b22:	601a      	str	r2, [r3, #0]
                    break;
 8000b24:	e06c      	b.n	8000c00 <xTaskIncrementTick+0x158>
                        xNextTaskUnblockTime = xItemValue;
 8000b26:	4b47      	ldr	r3, [pc, #284]	; (8000c44 <xTaskIncrementTick+0x19c>)
 8000b28:	601f      	str	r7, [r3, #0]
                        break; /*lint !e9011 Code structure here is deemed easier to understand with multiple breaks. */
 8000b2a:	e069      	b.n	8000c00 <xTaskIncrementTick+0x158>
                    prvAddTaskToReadyList( pxTCB );
 8000b2c:	6adf      	ldr	r7, [r3, #44]	; 0x2c
 8000b2e:	f8dc a000 	ldr.w	sl, [ip]
 8000b32:	fa0b f907 	lsl.w	r9, fp, r7
 8000b36:	ea49 090a 	orr.w	r9, r9, sl
 8000b3a:	f8cc 9000 	str.w	r9, [ip]
 8000b3e:	eb07 0787 	add.w	r7, r7, r7, lsl #2
 8000b42:	eb02 0787 	add.w	r7, r2, r7, lsl #2
 8000b46:	687f      	ldr	r7, [r7, #4]
 8000b48:	609f      	str	r7, [r3, #8]
 8000b4a:	f8d7 9008 	ldr.w	r9, [r7, #8]
 8000b4e:	f8c3 900c 	str.w	r9, [r3, #12]
 8000b52:	f8c9 8004 	str.w	r8, [r9, #4]
 8000b56:	f8c7 8008 	str.w	r8, [r7, #8]
 8000b5a:	6adf      	ldr	r7, [r3, #44]	; 0x2c
 8000b5c:	eb07 0887 	add.w	r8, r7, r7, lsl #2
 8000b60:	eb02 0988 	add.w	r9, r2, r8, lsl #2
 8000b64:	f8c3 9014 	str.w	r9, [r3, #20]
 8000b68:	f852 8028 	ldr.w	r8, [r2, r8, lsl #2]
 8000b6c:	f108 0801 	add.w	r8, r8, #1
 8000b70:	eb07 0787 	add.w	r7, r7, r7, lsl #2
 8000b74:	f842 8027 	str.w	r8, [r2, r7, lsl #2]
                            if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8000b78:	f8de 8000 	ldr.w	r8, [lr]
 8000b7c:	6adf      	ldr	r7, [r3, #44]	; 0x2c
 8000b7e:	f8d8 302c 	ldr.w	r3, [r8, #44]	; 0x2c
                                xSwitchRequired = pdTRUE;
 8000b82:	429f      	cmp	r7, r3
 8000b84:	bf28      	it	cs
 8000b86:	2001      	movcs	r0, #1
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8000b88:	680b      	ldr	r3, [r1, #0]
 8000b8a:	681b      	ldr	r3, [r3, #0]
 8000b8c:	2b00      	cmp	r3, #0
 8000b8e:	d0c5      	beq.n	8000b1c <xTaskIncrementTick+0x74>
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8000b90:	680b      	ldr	r3, [r1, #0]
 8000b92:	68db      	ldr	r3, [r3, #12]
 8000b94:	68db      	ldr	r3, [r3, #12]
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 8000b96:	685f      	ldr	r7, [r3, #4]
                    if( xConstTickCount < xItemValue )
 8000b98:	42bc      	cmp	r4, r7
 8000b9a:	d3c4      	bcc.n	8000b26 <xTaskIncrementTick+0x7e>
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 8000b9c:	695f      	ldr	r7, [r3, #20]
 8000b9e:	f8d3 800c 	ldr.w	r8, [r3, #12]
 8000ba2:	689e      	ldr	r6, [r3, #8]
 8000ba4:	f8c6 8008 	str.w	r8, [r6, #8]
 8000ba8:	689e      	ldr	r6, [r3, #8]
 8000baa:	f8c8 6004 	str.w	r6, [r8, #4]
 8000bae:	f103 0804 	add.w	r8, r3, #4
 8000bb2:	687e      	ldr	r6, [r7, #4]
 8000bb4:	4546      	cmp	r6, r8
 8000bb6:	bf04      	itt	eq
 8000bb8:	68de      	ldreq	r6, [r3, #12]
 8000bba:	607e      	streq	r6, [r7, #4]
 8000bbc:	615d      	str	r5, [r3, #20]
 8000bbe:	f8d7 9000 	ldr.w	r9, [r7]
 8000bc2:	f109 39ff 	add.w	r9, r9, #4294967295
 8000bc6:	f8c7 9000 	str.w	r9, [r7]
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8000bca:	f8d3 9028 	ldr.w	r9, [r3, #40]	; 0x28
 8000bce:	f1b9 0f00 	cmp.w	r9, #0
 8000bd2:	d0ab      	beq.n	8000b2c <xTaskIncrementTick+0x84>
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
 8000bd4:	6a1f      	ldr	r7, [r3, #32]
 8000bd6:	69de      	ldr	r6, [r3, #28]
 8000bd8:	60b7      	str	r7, [r6, #8]
 8000bda:	69de      	ldr	r6, [r3, #28]
 8000bdc:	607e      	str	r6, [r7, #4]
 8000bde:	f103 0718 	add.w	r7, r3, #24
 8000be2:	f8d9 6004 	ldr.w	r6, [r9, #4]
 8000be6:	42be      	cmp	r6, r7
 8000be8:	bf04      	itt	eq
 8000bea:	6a1f      	ldreq	r7, [r3, #32]
 8000bec:	f8c9 7004 	streq.w	r7, [r9, #4]
 8000bf0:	629d      	str	r5, [r3, #40]	; 0x28
 8000bf2:	f8d9 7000 	ldr.w	r7, [r9]
 8000bf6:	3f01      	subs	r7, #1
 8000bf8:	f8c9 7000 	str.w	r7, [r9]
 8000bfc:	e796      	b.n	8000b2c <xTaskIncrementTick+0x84>
    BaseType_t xSwitchRequired = pdFALSE;
 8000bfe:	2000      	movs	r0, #0
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 8000c00:	4b12      	ldr	r3, [pc, #72]	; (8000c4c <xTaskIncrementTick+0x1a4>)
 8000c02:	681b      	ldr	r3, [r3, #0]
 8000c04:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000c06:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8000c0a:	009b      	lsls	r3, r3, #2
 8000c0c:	4a0e      	ldr	r2, [pc, #56]	; (8000c48 <xTaskIncrementTick+0x1a0>)
 8000c0e:	58d3      	ldr	r3, [r2, r3]
                    xSwitchRequired = pdTRUE;
 8000c10:	2b02      	cmp	r3, #2
 8000c12:	bf28      	it	cs
 8000c14:	2001      	movcs	r0, #1
                if( xYieldPending != pdFALSE )
 8000c16:	4b0e      	ldr	r3, [pc, #56]	; (8000c50 <xTaskIncrementTick+0x1a8>)
 8000c18:	681b      	ldr	r3, [r3, #0]
                    xSwitchRequired = pdTRUE;
 8000c1a:	2b00      	cmp	r3, #0
 8000c1c:	bf18      	it	ne
 8000c1e:	2001      	movne	r0, #1
 8000c20:	e004      	b.n	8000c2c <xTaskIncrementTick+0x184>
        ++xPendedTicks;
 8000c22:	4a0c      	ldr	r2, [pc, #48]	; (8000c54 <xTaskIncrementTick+0x1ac>)
 8000c24:	6813      	ldr	r3, [r2, #0]
 8000c26:	3301      	adds	r3, #1
 8000c28:	6013      	str	r3, [r2, #0]
    BaseType_t xSwitchRequired = pdFALSE;
 8000c2a:	2000      	movs	r0, #0
}
 8000c2c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000c30:	200000d0 	.word	0x200000d0
 8000c34:	20000154 	.word	0x20000154
 8000c38:	20000054 	.word	0x20000054
 8000c3c:	20000058 	.word	0x20000058
 8000c40:	2000010c 	.word	0x2000010c
 8000c44:	20000108 	.word	0x20000108
 8000c48:	2000005c 	.word	0x2000005c
 8000c4c:	20000050 	.word	0x20000050
 8000c50:	20000158 	.word	0x20000158
 8000c54:	20000110 	.word	0x20000110
 8000c58:	200000d8 	.word	0x200000d8

08000c5c <xTaskResumeAll>:
    configASSERT( uxSchedulerSuspended );
 8000c5c:	4b55      	ldr	r3, [pc, #340]	; (8000db4 <xTaskResumeAll+0x158>)
 8000c5e:	681b      	ldr	r3, [r3, #0]
 8000c60:	b943      	cbnz	r3, 8000c74 <xTaskResumeAll+0x18>
 8000c62:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000c66:	f383 8811 	msr	BASEPRI, r3
 8000c6a:	f3bf 8f6f 	isb	sy
 8000c6e:	f3bf 8f4f 	dsb	sy
 8000c72:	e7fe      	b.n	8000c72 <xTaskResumeAll+0x16>
{
 8000c74:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    taskENTER_CRITICAL();
 8000c78:	f000 fcd2 	bl	8001620 <vPortEnterCritical>
        --uxSchedulerSuspended;
 8000c7c:	4b4d      	ldr	r3, [pc, #308]	; (8000db4 <xTaskResumeAll+0x158>)
 8000c7e:	681a      	ldr	r2, [r3, #0]
 8000c80:	3a01      	subs	r2, #1
 8000c82:	601a      	str	r2, [r3, #0]
        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8000c84:	681b      	ldr	r3, [r3, #0]
 8000c86:	2b00      	cmp	r3, #0
 8000c88:	f040 808b 	bne.w	8000da2 <xTaskResumeAll+0x146>
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 8000c8c:	4b4a      	ldr	r3, [pc, #296]	; (8000db8 <xTaskResumeAll+0x15c>)
 8000c8e:	681b      	ldr	r3, [r3, #0]
 8000c90:	2b00      	cmp	r3, #0
 8000c92:	f000 808c 	beq.w	8000dae <xTaskResumeAll+0x152>
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8000c96:	4b49      	ldr	r3, [pc, #292]	; (8000dbc <xTaskResumeAll+0x160>)
 8000c98:	681b      	ldr	r3, [r3, #0]
 8000c9a:	2b00      	cmp	r3, #0
 8000c9c:	d061      	beq.n	8000d62 <xTaskResumeAll+0x106>
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8000c9e:	f8df c11c 	ldr.w	ip, [pc, #284]	; 8000dbc <xTaskResumeAll+0x160>
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
 8000ca2:	2000      	movs	r0, #0
                    prvAddTaskToReadyList( pxTCB );
 8000ca4:	4946      	ldr	r1, [pc, #280]	; (8000dc0 <xTaskResumeAll+0x164>)
 8000ca6:	f04f 0e01 	mov.w	lr, #1
 8000caa:	4a46      	ldr	r2, [pc, #280]	; (8000dc4 <xTaskResumeAll+0x168>)
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8000cac:	4c46      	ldr	r4, [pc, #280]	; (8000dc8 <xTaskResumeAll+0x16c>)
                        xYieldPending = pdTRUE;
 8000cae:	f8df a120 	ldr.w	sl, [pc, #288]	; 8000dd0 <xTaskResumeAll+0x174>
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8000cb2:	f8dc 300c 	ldr.w	r3, [ip, #12]
 8000cb6:	68db      	ldr	r3, [r3, #12]
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
 8000cb8:	6a9e      	ldr	r6, [r3, #40]	; 0x28
 8000cba:	6a1f      	ldr	r7, [r3, #32]
 8000cbc:	69dd      	ldr	r5, [r3, #28]
 8000cbe:	60af      	str	r7, [r5, #8]
 8000cc0:	69dd      	ldr	r5, [r3, #28]
 8000cc2:	607d      	str	r5, [r7, #4]
 8000cc4:	f103 0718 	add.w	r7, r3, #24
 8000cc8:	6875      	ldr	r5, [r6, #4]
 8000cca:	42bd      	cmp	r5, r7
 8000ccc:	bf04      	itt	eq
 8000cce:	6a1d      	ldreq	r5, [r3, #32]
 8000cd0:	6075      	streq	r5, [r6, #4]
 8000cd2:	6298      	str	r0, [r3, #40]	; 0x28
 8000cd4:	6837      	ldr	r7, [r6, #0]
 8000cd6:	3f01      	subs	r7, #1
 8000cd8:	6037      	str	r7, [r6, #0]
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
 8000cda:	695e      	ldr	r6, [r3, #20]
 8000cdc:	68df      	ldr	r7, [r3, #12]
 8000cde:	689d      	ldr	r5, [r3, #8]
 8000ce0:	60af      	str	r7, [r5, #8]
 8000ce2:	689d      	ldr	r5, [r3, #8]
 8000ce4:	607d      	str	r5, [r7, #4]
 8000ce6:	1d1f      	adds	r7, r3, #4
 8000ce8:	6875      	ldr	r5, [r6, #4]
 8000cea:	42bd      	cmp	r5, r7
 8000cec:	bf04      	itt	eq
 8000cee:	68dd      	ldreq	r5, [r3, #12]
 8000cf0:	6075      	streq	r5, [r6, #4]
 8000cf2:	6158      	str	r0, [r3, #20]
 8000cf4:	f8d6 8000 	ldr.w	r8, [r6]
 8000cf8:	f108 38ff 	add.w	r8, r8, #4294967295
 8000cfc:	f8c6 8000 	str.w	r8, [r6]
                    prvAddTaskToReadyList( pxTCB );
 8000d00:	6ade      	ldr	r6, [r3, #44]	; 0x2c
 8000d02:	f8d1 9000 	ldr.w	r9, [r1]
 8000d06:	fa0e f806 	lsl.w	r8, lr, r6
 8000d0a:	ea48 0809 	orr.w	r8, r8, r9
 8000d0e:	f8c1 8000 	str.w	r8, [r1]
 8000d12:	eb06 0686 	add.w	r6, r6, r6, lsl #2
 8000d16:	eb02 0686 	add.w	r6, r2, r6, lsl #2
 8000d1a:	6876      	ldr	r6, [r6, #4]
 8000d1c:	609e      	str	r6, [r3, #8]
 8000d1e:	f8d6 8008 	ldr.w	r8, [r6, #8]
 8000d22:	f8c3 800c 	str.w	r8, [r3, #12]
 8000d26:	f8c8 7004 	str.w	r7, [r8, #4]
 8000d2a:	60b7      	str	r7, [r6, #8]
 8000d2c:	6ade      	ldr	r6, [r3, #44]	; 0x2c
 8000d2e:	eb06 0786 	add.w	r7, r6, r6, lsl #2
 8000d32:	eb02 0887 	add.w	r8, r2, r7, lsl #2
 8000d36:	f8c3 8014 	str.w	r8, [r3, #20]
 8000d3a:	f852 7027 	ldr.w	r7, [r2, r7, lsl #2]
 8000d3e:	3701      	adds	r7, #1
 8000d40:	eb06 0686 	add.w	r6, r6, r6, lsl #2
 8000d44:	f842 7026 	str.w	r7, [r2, r6, lsl #2]
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8000d48:	6827      	ldr	r7, [r4, #0]
 8000d4a:	6ade      	ldr	r6, [r3, #44]	; 0x2c
 8000d4c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8000d4e:	429e      	cmp	r6, r3
                        xYieldPending = pdTRUE;
 8000d50:	bf28      	it	cs
 8000d52:	f8ca e000 	strcs.w	lr, [sl]
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8000d56:	f8dc 3000 	ldr.w	r3, [ip]
 8000d5a:	2b00      	cmp	r3, #0
 8000d5c:	d1a9      	bne.n	8000cb2 <xTaskResumeAll+0x56>
                    prvResetNextTaskUnblockTime();
 8000d5e:	f7ff fc2b 	bl	80005b8 <prvResetNextTaskUnblockTime>
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
 8000d62:	4b1a      	ldr	r3, [pc, #104]	; (8000dcc <xTaskResumeAll+0x170>)
 8000d64:	681c      	ldr	r4, [r3, #0]
                    if( xPendedCounts > ( TickType_t ) 0U )
 8000d66:	b16c      	cbz	r4, 8000d84 <xTaskResumeAll+0x128>
                                xYieldPending = pdTRUE;
 8000d68:	4e19      	ldr	r6, [pc, #100]	; (8000dd0 <xTaskResumeAll+0x174>)
 8000d6a:	2501      	movs	r5, #1
 8000d6c:	e001      	b.n	8000d72 <xTaskResumeAll+0x116>
                        } while( xPendedCounts > ( TickType_t ) 0U );
 8000d6e:	3c01      	subs	r4, #1
 8000d70:	d005      	beq.n	8000d7e <xTaskResumeAll+0x122>
                            if( xTaskIncrementTick() != pdFALSE )
 8000d72:	f7ff fe99 	bl	8000aa8 <xTaskIncrementTick>
 8000d76:	2800      	cmp	r0, #0
 8000d78:	d0f9      	beq.n	8000d6e <xTaskResumeAll+0x112>
                                xYieldPending = pdTRUE;
 8000d7a:	6035      	str	r5, [r6, #0]
 8000d7c:	e7f7      	b.n	8000d6e <xTaskResumeAll+0x112>
                        xPendedTicks = 0;
 8000d7e:	4b13      	ldr	r3, [pc, #76]	; (8000dcc <xTaskResumeAll+0x170>)
 8000d80:	2200      	movs	r2, #0
 8000d82:	601a      	str	r2, [r3, #0]
                if( xYieldPending != pdFALSE )
 8000d84:	4b12      	ldr	r3, [pc, #72]	; (8000dd0 <xTaskResumeAll+0x174>)
 8000d86:	681c      	ldr	r4, [r3, #0]
 8000d88:	b164      	cbz	r4, 8000da4 <xTaskResumeAll+0x148>
                    taskYIELD_IF_USING_PREEMPTION();
 8000d8a:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8000d8e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8000d92:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8000d96:	f3bf 8f4f 	dsb	sy
 8000d9a:	f3bf 8f6f 	isb	sy
                            xAlreadyYielded = pdTRUE;
 8000d9e:	2401      	movs	r4, #1
 8000da0:	e000      	b.n	8000da4 <xTaskResumeAll+0x148>
    BaseType_t xAlreadyYielded = pdFALSE;
 8000da2:	2400      	movs	r4, #0
    taskEXIT_CRITICAL();
 8000da4:	f000 fc5e 	bl	8001664 <vPortExitCritical>
}
 8000da8:	4620      	mov	r0, r4
 8000daa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    BaseType_t xAlreadyYielded = pdFALSE;
 8000dae:	2400      	movs	r4, #0
 8000db0:	e7f8      	b.n	8000da4 <xTaskResumeAll+0x148>
 8000db2:	bf00      	nop
 8000db4:	200000d0 	.word	0x200000d0
 8000db8:	200000c8 	.word	0x200000c8
 8000dbc:	20000114 	.word	0x20000114
 8000dc0:	200000d8 	.word	0x200000d8
 8000dc4:	2000005c 	.word	0x2000005c
 8000dc8:	20000050 	.word	0x20000050
 8000dcc:	20000110 	.word	0x20000110
 8000dd0:	20000158 	.word	0x20000158

08000dd4 <vTaskDelay>:
    {
 8000dd4:	b510      	push	{r4, lr}
        if( xTicksToDelay > ( TickType_t ) 0U )
 8000dd6:	b1a8      	cbz	r0, 8000e04 <vTaskDelay+0x30>
 8000dd8:	4604      	mov	r4, r0
            configASSERT( uxSchedulerSuspended == 0 );
 8000dda:	4b10      	ldr	r3, [pc, #64]	; (8000e1c <vTaskDelay+0x48>)
 8000ddc:	681b      	ldr	r3, [r3, #0]
 8000dde:	b143      	cbz	r3, 8000df2 <vTaskDelay+0x1e>
 8000de0:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000de4:	f383 8811 	msr	BASEPRI, r3
 8000de8:	f3bf 8f6f 	isb	sy
 8000dec:	f3bf 8f4f 	dsb	sy
 8000df0:	e7fe      	b.n	8000df0 <vTaskDelay+0x1c>
            vTaskSuspendAll();
 8000df2:	f7ff fe4b 	bl	8000a8c <vTaskSuspendAll>
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 8000df6:	2100      	movs	r1, #0
 8000df8:	4620      	mov	r0, r4
 8000dfa:	f7ff fd2f 	bl	800085c <prvAddCurrentTaskToDelayedList>
            xAlreadyYielded = xTaskResumeAll();
 8000dfe:	f7ff ff2d 	bl	8000c5c <xTaskResumeAll>
        if( xAlreadyYielded == pdFALSE )
 8000e02:	b948      	cbnz	r0, 8000e18 <vTaskDelay+0x44>
            portYIELD_WITHIN_API();
 8000e04:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8000e08:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8000e0c:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 8000e10:	f3bf 8f4f 	dsb	sy
 8000e14:	f3bf 8f6f 	isb	sy
    }
 8000e18:	bd10      	pop	{r4, pc}
 8000e1a:	bf00      	nop
 8000e1c:	200000d0 	.word	0x200000d0

08000e20 <vTaskSwitchContext>:
{
 8000e20:	b508      	push	{r3, lr}
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 8000e22:	4b36      	ldr	r3, [pc, #216]	; (8000efc <vTaskSwitchContext+0xdc>)
 8000e24:	681b      	ldr	r3, [r3, #0]
 8000e26:	b11b      	cbz	r3, 8000e30 <vTaskSwitchContext+0x10>
        xYieldPending = pdTRUE;
 8000e28:	4b35      	ldr	r3, [pc, #212]	; (8000f00 <vTaskSwitchContext+0xe0>)
 8000e2a:	2201      	movs	r2, #1
 8000e2c:	601a      	str	r2, [r3, #0]
}
 8000e2e:	bd08      	pop	{r3, pc}
        xYieldPending = pdFALSE;
 8000e30:	2200      	movs	r2, #0
 8000e32:	4b33      	ldr	r3, [pc, #204]	; (8000f00 <vTaskSwitchContext+0xe0>)
 8000e34:	601a      	str	r2, [r3, #0]
                    ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
 8000e36:	4b33      	ldr	r3, [pc, #204]	; (8000f04 <vTaskSwitchContext+0xe4>)
 8000e38:	601a      	str	r2, [r3, #0]
                if( ulTotalRunTime > ulTaskSwitchedInTime )
 8000e3a:	681b      	ldr	r3, [r3, #0]
 8000e3c:	4a32      	ldr	r2, [pc, #200]	; (8000f08 <vTaskSwitchContext+0xe8>)
 8000e3e:	6812      	ldr	r2, [r2, #0]
 8000e40:	4293      	cmp	r3, r2
 8000e42:	d907      	bls.n	8000e54 <vTaskSwitchContext+0x34>
                    pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
 8000e44:	4b2f      	ldr	r3, [pc, #188]	; (8000f04 <vTaskSwitchContext+0xe4>)
 8000e46:	6818      	ldr	r0, [r3, #0]
 8000e48:	4b30      	ldr	r3, [pc, #192]	; (8000f0c <vTaskSwitchContext+0xec>)
 8000e4a:	6819      	ldr	r1, [r3, #0]
 8000e4c:	6dcb      	ldr	r3, [r1, #92]	; 0x5c
 8000e4e:	1a9b      	subs	r3, r3, r2
 8000e50:	4403      	add	r3, r0
 8000e52:	65cb      	str	r3, [r1, #92]	; 0x5c
                ulTaskSwitchedInTime = ulTotalRunTime;
 8000e54:	4b2b      	ldr	r3, [pc, #172]	; (8000f04 <vTaskSwitchContext+0xe4>)
 8000e56:	681a      	ldr	r2, [r3, #0]
 8000e58:	4b2b      	ldr	r3, [pc, #172]	; (8000f08 <vTaskSwitchContext+0xe8>)
 8000e5a:	601a      	str	r2, [r3, #0]
        taskCHECK_FOR_STACK_OVERFLOW();
 8000e5c:	4b2b      	ldr	r3, [pc, #172]	; (8000f0c <vTaskSwitchContext+0xec>)
 8000e5e:	681b      	ldr	r3, [r3, #0]
 8000e60:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000e62:	681a      	ldr	r2, [r3, #0]
 8000e64:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
 8000e68:	d103      	bne.n	8000e72 <vTaskSwitchContext+0x52>
 8000e6a:	685a      	ldr	r2, [r3, #4]
 8000e6c:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
 8000e70:	d01b      	beq.n	8000eaa <vTaskSwitchContext+0x8a>
 8000e72:	4b26      	ldr	r3, [pc, #152]	; (8000f0c <vTaskSwitchContext+0xec>)
 8000e74:	6818      	ldr	r0, [r3, #0]
 8000e76:	6819      	ldr	r1, [r3, #0]
 8000e78:	3134      	adds	r1, #52	; 0x34
 8000e7a:	f000 fe1a 	bl	8001ab2 <vApplicationStackOverflowHook>
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8000e7e:	4b24      	ldr	r3, [pc, #144]	; (8000f10 <vTaskSwitchContext+0xf0>)
 8000e80:	681b      	ldr	r3, [r3, #0]
            __asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
 8000e82:	fab3 f383 	clz	r3, r3
 8000e86:	b2db      	uxtb	r3, r3
 8000e88:	f1c3 031f 	rsb	r3, r3, #31
 8000e8c:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 8000e90:	0092      	lsls	r2, r2, #2
 8000e92:	4920      	ldr	r1, [pc, #128]	; (8000f14 <vTaskSwitchContext+0xf4>)
 8000e94:	588a      	ldr	r2, [r1, r2]
 8000e96:	b98a      	cbnz	r2, 8000ebc <vTaskSwitchContext+0x9c>
        __asm volatile
 8000e98:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000e9c:	f383 8811 	msr	BASEPRI, r3
 8000ea0:	f3bf 8f6f 	isb	sy
 8000ea4:	f3bf 8f4f 	dsb	sy
 8000ea8:	e7fe      	b.n	8000ea8 <vTaskSwitchContext+0x88>
        taskCHECK_FOR_STACK_OVERFLOW();
 8000eaa:	689a      	ldr	r2, [r3, #8]
 8000eac:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
 8000eb0:	d1df      	bne.n	8000e72 <vTaskSwitchContext+0x52>
 8000eb2:	68db      	ldr	r3, [r3, #12]
 8000eb4:	f1b3 3fa5 	cmp.w	r3, #2779096485	; 0xa5a5a5a5
 8000eb8:	d1db      	bne.n	8000e72 <vTaskSwitchContext+0x52>
 8000eba:	e7e0      	b.n	8000e7e <vTaskSwitchContext+0x5e>
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8000ebc:	4a15      	ldr	r2, [pc, #84]	; (8000f14 <vTaskSwitchContext+0xf4>)
 8000ebe:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 8000ec2:	eb02 0181 	add.w	r1, r2, r1, lsl #2
 8000ec6:	6848      	ldr	r0, [r1, #4]
 8000ec8:	6840      	ldr	r0, [r0, #4]
 8000eca:	6048      	str	r0, [r1, #4]
 8000ecc:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 8000ed0:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 8000ed4:	3208      	adds	r2, #8
 8000ed6:	4290      	cmp	r0, r2
 8000ed8:	d009      	beq.n	8000eee <vTaskSwitchContext+0xce>
 8000eda:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8000ede:	4a0d      	ldr	r2, [pc, #52]	; (8000f14 <vTaskSwitchContext+0xf4>)
 8000ee0:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8000ee4:	685b      	ldr	r3, [r3, #4]
 8000ee6:	68da      	ldr	r2, [r3, #12]
 8000ee8:	4b08      	ldr	r3, [pc, #32]	; (8000f0c <vTaskSwitchContext+0xec>)
 8000eea:	601a      	str	r2, [r3, #0]
}
 8000eec:	e79f      	b.n	8000e2e <vTaskSwitchContext+0xe>
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8000eee:	6840      	ldr	r0, [r0, #4]
 8000ef0:	4a08      	ldr	r2, [pc, #32]	; (8000f14 <vTaskSwitchContext+0xf4>)
 8000ef2:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 8000ef6:	6050      	str	r0, [r2, #4]
 8000ef8:	e7ef      	b.n	8000eda <vTaskSwitchContext+0xba>
 8000efa:	bf00      	nop
 8000efc:	200000d0 	.word	0x200000d0
 8000f00:	20000158 	.word	0x20000158
 8000f04:	200000c4 	.word	0x200000c4
 8000f08:	200000c0 	.word	0x200000c0
 8000f0c:	20000050 	.word	0x20000050
 8000f10:	200000d8 	.word	0x200000d8
 8000f14:	2000005c 	.word	0x2000005c

08000f18 <vTaskPlaceOnEventList>:
    configASSERT( pxEventList );
 8000f18:	b158      	cbz	r0, 8000f32 <vTaskPlaceOnEventList+0x1a>
{
 8000f1a:	b510      	push	{r4, lr}
 8000f1c:	460c      	mov	r4, r1
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8000f1e:	4a09      	ldr	r2, [pc, #36]	; (8000f44 <vTaskPlaceOnEventList+0x2c>)
 8000f20:	6811      	ldr	r1, [r2, #0]
 8000f22:	3118      	adds	r1, #24
 8000f24:	f7ff f89a 	bl	800005c <vListInsert>
    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 8000f28:	2101      	movs	r1, #1
 8000f2a:	4620      	mov	r0, r4
 8000f2c:	f7ff fc96 	bl	800085c <prvAddCurrentTaskToDelayedList>
}
 8000f30:	bd10      	pop	{r4, pc}
 8000f32:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000f36:	f383 8811 	msr	BASEPRI, r3
 8000f3a:	f3bf 8f6f 	isb	sy
 8000f3e:	f3bf 8f4f 	dsb	sy
    configASSERT( pxEventList );
 8000f42:	e7fe      	b.n	8000f42 <vTaskPlaceOnEventList+0x2a>
 8000f44:	20000050 	.word	0x20000050

08000f48 <vTaskPlaceOnEventListRestricted>:
    {
 8000f48:	b538      	push	{r3, r4, r5, lr}
        configASSERT( pxEventList );
 8000f4a:	b1e0      	cbz	r0, 8000f86 <vTaskPlaceOnEventListRestricted+0x3e>
 8000f4c:	468c      	mov	ip, r1
 8000f4e:	4611      	mov	r1, r2
 8000f50:	4605      	mov	r5, r0
        listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8000f52:	6842      	ldr	r2, [r0, #4]
 8000f54:	4b10      	ldr	r3, [pc, #64]	; (8000f98 <vTaskPlaceOnEventListRestricted+0x50>)
 8000f56:	6818      	ldr	r0, [r3, #0]
 8000f58:	61c2      	str	r2, [r0, #28]
 8000f5a:	6818      	ldr	r0, [r3, #0]
 8000f5c:	6894      	ldr	r4, [r2, #8]
 8000f5e:	6204      	str	r4, [r0, #32]
 8000f60:	6818      	ldr	r0, [r3, #0]
 8000f62:	3018      	adds	r0, #24
 8000f64:	6060      	str	r0, [r4, #4]
 8000f66:	6818      	ldr	r0, [r3, #0]
 8000f68:	3018      	adds	r0, #24
 8000f6a:	6090      	str	r0, [r2, #8]
 8000f6c:	681b      	ldr	r3, [r3, #0]
 8000f6e:	629d      	str	r5, [r3, #40]	; 0x28
 8000f70:	682b      	ldr	r3, [r5, #0]
 8000f72:	3301      	adds	r3, #1
 8000f74:	602b      	str	r3, [r5, #0]
            xTicksToWait = portMAX_DELAY;
 8000f76:	2900      	cmp	r1, #0
        prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
 8000f78:	bf0c      	ite	eq
 8000f7a:	4660      	moveq	r0, ip
 8000f7c:	f04f 30ff 	movne.w	r0, #4294967295
 8000f80:	f7ff fc6c 	bl	800085c <prvAddCurrentTaskToDelayedList>
    }
 8000f84:	bd38      	pop	{r3, r4, r5, pc}
 8000f86:	f04f 0350 	mov.w	r3, #80	; 0x50
 8000f8a:	f383 8811 	msr	BASEPRI, r3
 8000f8e:	f3bf 8f6f 	isb	sy
 8000f92:	f3bf 8f4f 	dsb	sy
        configASSERT( pxEventList );
 8000f96:	e7fe      	b.n	8000f96 <vTaskPlaceOnEventListRestricted+0x4e>
 8000f98:	20000050 	.word	0x20000050

08000f9c <xTaskRemoveFromEventList>:
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8000f9c:	68c3      	ldr	r3, [r0, #12]
 8000f9e:	68db      	ldr	r3, [r3, #12]
    configASSERT( pxUnblockedTCB );
 8000fa0:	2b00      	cmp	r3, #0
 8000fa2:	d04f      	beq.n	8001044 <xTaskRemoveFromEventList+0xa8>
{
 8000fa4:	b430      	push	{r4, r5}
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
 8000fa6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8000fa8:	69d8      	ldr	r0, [r3, #28]
 8000faa:	6a19      	ldr	r1, [r3, #32]
 8000fac:	6081      	str	r1, [r0, #8]
 8000fae:	69d8      	ldr	r0, [r3, #28]
 8000fb0:	6048      	str	r0, [r1, #4]
 8000fb2:	f103 0018 	add.w	r0, r3, #24
 8000fb6:	6851      	ldr	r1, [r2, #4]
 8000fb8:	4281      	cmp	r1, r0
 8000fba:	bf04      	itt	eq
 8000fbc:	6a19      	ldreq	r1, [r3, #32]
 8000fbe:	6051      	streq	r1, [r2, #4]
 8000fc0:	2100      	movs	r1, #0
 8000fc2:	6299      	str	r1, [r3, #40]	; 0x28
 8000fc4:	6811      	ldr	r1, [r2, #0]
 8000fc6:	3901      	subs	r1, #1
 8000fc8:	6011      	str	r1, [r2, #0]
    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8000fca:	4a29      	ldr	r2, [pc, #164]	; (8001070 <xTaskRemoveFromEventList+0xd4>)
 8000fcc:	6812      	ldr	r2, [r2, #0]
 8000fce:	2a00      	cmp	r2, #0
 8000fd0:	d141      	bne.n	8001056 <xTaskRemoveFromEventList+0xba>
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
 8000fd2:	695a      	ldr	r2, [r3, #20]
 8000fd4:	6898      	ldr	r0, [r3, #8]
 8000fd6:	68d9      	ldr	r1, [r3, #12]
 8000fd8:	6081      	str	r1, [r0, #8]
 8000fda:	6898      	ldr	r0, [r3, #8]
 8000fdc:	6048      	str	r0, [r1, #4]
 8000fde:	1d18      	adds	r0, r3, #4
 8000fe0:	6851      	ldr	r1, [r2, #4]
 8000fe2:	4281      	cmp	r1, r0
 8000fe4:	bf04      	itt	eq
 8000fe6:	68d9      	ldreq	r1, [r3, #12]
 8000fe8:	6051      	streq	r1, [r2, #4]
 8000fea:	2100      	movs	r1, #0
 8000fec:	6159      	str	r1, [r3, #20]
 8000fee:	6811      	ldr	r1, [r2, #0]
 8000ff0:	3901      	subs	r1, #1
 8000ff2:	6011      	str	r1, [r2, #0]
        prvAddTaskToReadyList( pxUnblockedTCB );
 8000ff4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8000ff6:	4c1f      	ldr	r4, [pc, #124]	; (8001074 <xTaskRemoveFromEventList+0xd8>)
 8000ff8:	6825      	ldr	r5, [r4, #0]
 8000ffa:	2101      	movs	r1, #1
 8000ffc:	4091      	lsls	r1, r2
 8000ffe:	4329      	orrs	r1, r5
 8001000:	6021      	str	r1, [r4, #0]
 8001002:	491d      	ldr	r1, [pc, #116]	; (8001078 <xTaskRemoveFromEventList+0xdc>)
 8001004:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8001008:	eb01 0282 	add.w	r2, r1, r2, lsl #2
 800100c:	6852      	ldr	r2, [r2, #4]
 800100e:	609a      	str	r2, [r3, #8]
 8001010:	6894      	ldr	r4, [r2, #8]
 8001012:	60dc      	str	r4, [r3, #12]
 8001014:	6060      	str	r0, [r4, #4]
 8001016:	6090      	str	r0, [r2, #8]
 8001018:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800101a:	eb02 0082 	add.w	r0, r2, r2, lsl #2
 800101e:	0084      	lsls	r4, r0, #2
 8001020:	eb01 0080 	add.w	r0, r1, r0, lsl #2
 8001024:	6158      	str	r0, [r3, #20]
 8001026:	5908      	ldr	r0, [r1, r4]
 8001028:	3001      	adds	r0, #1
 800102a:	5108      	str	r0, [r1, r4]
    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 800102c:	4a13      	ldr	r2, [pc, #76]	; (800107c <xTaskRemoveFromEventList+0xe0>)
 800102e:	6811      	ldr	r1, [r2, #0]
 8001030:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001032:	6acb      	ldr	r3, [r1, #44]	; 0x2c
 8001034:	429a      	cmp	r2, r3
        xYieldPending = pdTRUE;
 8001036:	bf83      	ittte	hi
 8001038:	2001      	movhi	r0, #1
 800103a:	4b11      	ldrhi	r3, [pc, #68]	; (8001080 <xTaskRemoveFromEventList+0xe4>)
 800103c:	6018      	strhi	r0, [r3, #0]
        xReturn = pdFALSE;
 800103e:	2000      	movls	r0, #0
}
 8001040:	bc30      	pop	{r4, r5}
 8001042:	4770      	bx	lr
 8001044:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001048:	f383 8811 	msr	BASEPRI, r3
 800104c:	f3bf 8f6f 	isb	sy
 8001050:	f3bf 8f4f 	dsb	sy
    configASSERT( pxUnblockedTCB );
 8001054:	e7fe      	b.n	8001054 <xTaskRemoveFromEventList+0xb8>
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 8001056:	4a0b      	ldr	r2, [pc, #44]	; (8001084 <xTaskRemoveFromEventList+0xe8>)
 8001058:	6851      	ldr	r1, [r2, #4]
 800105a:	61d9      	str	r1, [r3, #28]
 800105c:	688c      	ldr	r4, [r1, #8]
 800105e:	621c      	str	r4, [r3, #32]
 8001060:	6060      	str	r0, [r4, #4]
 8001062:	6088      	str	r0, [r1, #8]
 8001064:	629a      	str	r2, [r3, #40]	; 0x28
 8001066:	6811      	ldr	r1, [r2, #0]
 8001068:	3101      	adds	r1, #1
 800106a:	6011      	str	r1, [r2, #0]
 800106c:	e7de      	b.n	800102c <xTaskRemoveFromEventList+0x90>
 800106e:	bf00      	nop
 8001070:	200000d0 	.word	0x200000d0
 8001074:	200000d8 	.word	0x200000d8
 8001078:	2000005c 	.word	0x2000005c
 800107c:	20000050 	.word	0x20000050
 8001080:	20000158 	.word	0x20000158
 8001084:	20000114 	.word	0x20000114

08001088 <vTaskInternalSetTimeOutState>:
    pxTimeOut->xOverflowCount = xNumOfOverflows;
 8001088:	4b03      	ldr	r3, [pc, #12]	; (8001098 <vTaskInternalSetTimeOutState+0x10>)
 800108a:	681b      	ldr	r3, [r3, #0]
 800108c:	6003      	str	r3, [r0, #0]
    pxTimeOut->xTimeOnEntering = xTickCount;
 800108e:	4b03      	ldr	r3, [pc, #12]	; (800109c <vTaskInternalSetTimeOutState+0x14>)
 8001090:	681b      	ldr	r3, [r3, #0]
 8001092:	6043      	str	r3, [r0, #4]
}
 8001094:	4770      	bx	lr
 8001096:	bf00      	nop
 8001098:	2000010c 	.word	0x2000010c
 800109c:	20000154 	.word	0x20000154

080010a0 <xTaskCheckForTimeOut>:
    configASSERT( pxTimeOut );
 80010a0:	b1b0      	cbz	r0, 80010d0 <xTaskCheckForTimeOut+0x30>
{
 80010a2:	b570      	push	{r4, r5, r6, lr}
 80010a4:	460c      	mov	r4, r1
 80010a6:	4605      	mov	r5, r0
    configASSERT( pxTicksToWait );
 80010a8:	b1d9      	cbz	r1, 80010e2 <xTaskCheckForTimeOut+0x42>
    taskENTER_CRITICAL();
 80010aa:	f000 fab9 	bl	8001620 <vPortEnterCritical>
        const TickType_t xConstTickCount = xTickCount;
 80010ae:	4b22      	ldr	r3, [pc, #136]	; (8001138 <xTaskCheckForTimeOut+0x98>)
 80010b0:	681a      	ldr	r2, [r3, #0]
            if( pxCurrentTCB->ucDelayAborted != ( uint8_t ) pdFALSE )
 80010b2:	4b22      	ldr	r3, [pc, #136]	; (800113c <xTaskCheckForTimeOut+0x9c>)
 80010b4:	681b      	ldr	r3, [r3, #0]
 80010b6:	f893 3066 	ldrb.w	r3, [r3, #102]	; 0x66
 80010ba:	b1db      	cbz	r3, 80010f4 <xTaskCheckForTimeOut+0x54>
                pxCurrentTCB->ucDelayAborted = pdFALSE;
 80010bc:	4b1f      	ldr	r3, [pc, #124]	; (800113c <xTaskCheckForTimeOut+0x9c>)
 80010be:	681b      	ldr	r3, [r3, #0]
 80010c0:	2200      	movs	r2, #0
 80010c2:	f883 2066 	strb.w	r2, [r3, #102]	; 0x66
                xReturn = pdTRUE;
 80010c6:	2401      	movs	r4, #1
    taskEXIT_CRITICAL();
 80010c8:	f000 facc 	bl	8001664 <vPortExitCritical>
}
 80010cc:	4620      	mov	r0, r4
 80010ce:	bd70      	pop	{r4, r5, r6, pc}
 80010d0:	f04f 0350 	mov.w	r3, #80	; 0x50
 80010d4:	f383 8811 	msr	BASEPRI, r3
 80010d8:	f3bf 8f6f 	isb	sy
 80010dc:	f3bf 8f4f 	dsb	sy
    configASSERT( pxTimeOut );
 80010e0:	e7fe      	b.n	80010e0 <xTaskCheckForTimeOut+0x40>
 80010e2:	f04f 0350 	mov.w	r3, #80	; 0x50
 80010e6:	f383 8811 	msr	BASEPRI, r3
 80010ea:	f3bf 8f6f 	isb	sy
 80010ee:	f3bf 8f4f 	dsb	sy
    configASSERT( pxTicksToWait );
 80010f2:	e7fe      	b.n	80010f2 <xTaskCheckForTimeOut+0x52>
            if( *pxTicksToWait == portMAX_DELAY )
 80010f4:	6823      	ldr	r3, [r4, #0]
 80010f6:	f1b3 3fff 	cmp.w	r3, #4294967295
 80010fa:	d01a      	beq.n	8001132 <xTaskCheckForTimeOut+0x92>
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 80010fc:	6869      	ldr	r1, [r5, #4]
        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 80010fe:	4810      	ldr	r0, [pc, #64]	; (8001140 <xTaskCheckForTimeOut+0xa0>)
 8001100:	6800      	ldr	r0, [r0, #0]
 8001102:	682e      	ldr	r6, [r5, #0]
 8001104:	4286      	cmp	r6, r0
 8001106:	d005      	beq.n	8001114 <xTaskCheckForTimeOut+0x74>
 8001108:	4291      	cmp	r1, r2
 800110a:	d803      	bhi.n	8001114 <xTaskCheckForTimeOut+0x74>
            *pxTicksToWait = ( TickType_t ) 0;
 800110c:	2300      	movs	r3, #0
 800110e:	6023      	str	r3, [r4, #0]
            xReturn = pdTRUE;
 8001110:	2401      	movs	r4, #1
            *pxTicksToWait = ( TickType_t ) 0;
 8001112:	e7d9      	b.n	80010c8 <xTaskCheckForTimeOut+0x28>
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 8001114:	1a50      	subs	r0, r2, r1
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 8001116:	4283      	cmp	r3, r0
 8001118:	d803      	bhi.n	8001122 <xTaskCheckForTimeOut+0x82>
            *pxTicksToWait = ( TickType_t ) 0;
 800111a:	2300      	movs	r3, #0
 800111c:	6023      	str	r3, [r4, #0]
            xReturn = pdTRUE;
 800111e:	2401      	movs	r4, #1
 8001120:	e7d2      	b.n	80010c8 <xTaskCheckForTimeOut+0x28>
            *pxTicksToWait -= xElapsedTime;
 8001122:	1a9b      	subs	r3, r3, r2
 8001124:	440b      	add	r3, r1
 8001126:	6023      	str	r3, [r4, #0]
            vTaskInternalSetTimeOutState( pxTimeOut );
 8001128:	4628      	mov	r0, r5
 800112a:	f7ff ffad 	bl	8001088 <vTaskInternalSetTimeOutState>
            xReturn = pdFALSE;
 800112e:	2400      	movs	r4, #0
 8001130:	e7ca      	b.n	80010c8 <xTaskCheckForTimeOut+0x28>
                xReturn = pdFALSE;
 8001132:	2400      	movs	r4, #0
 8001134:	e7c8      	b.n	80010c8 <xTaskCheckForTimeOut+0x28>
 8001136:	bf00      	nop
 8001138:	20000154 	.word	0x20000154
 800113c:	20000050 	.word	0x20000050
 8001140:	2000010c 	.word	0x2000010c

08001144 <vTaskMissedYield>:
    xYieldPending = pdTRUE;
 8001144:	4b01      	ldr	r3, [pc, #4]	; (800114c <vTaskMissedYield+0x8>)
 8001146:	2201      	movs	r2, #1
 8001148:	601a      	str	r2, [r3, #0]
}
 800114a:	4770      	bx	lr
 800114c:	20000158 	.word	0x20000158

08001150 <xTaskGetSchedulerState>:
        if( xSchedulerRunning == pdFALSE )
 8001150:	4b05      	ldr	r3, [pc, #20]	; (8001168 <xTaskGetSchedulerState+0x18>)
 8001152:	681b      	ldr	r3, [r3, #0]
 8001154:	b133      	cbz	r3, 8001164 <xTaskGetSchedulerState+0x14>
            if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8001156:	4b05      	ldr	r3, [pc, #20]	; (800116c <xTaskGetSchedulerState+0x1c>)
 8001158:	681b      	ldr	r3, [r3, #0]
                xReturn = taskSCHEDULER_SUSPENDED;
 800115a:	2b00      	cmp	r3, #0
 800115c:	bf0c      	ite	eq
 800115e:	2002      	moveq	r0, #2
 8001160:	2000      	movne	r0, #0
 8001162:	4770      	bx	lr
            xReturn = taskSCHEDULER_NOT_STARTED;
 8001164:	2001      	movs	r0, #1
    }
 8001166:	4770      	bx	lr
 8001168:	20000128 	.word	0x20000128
 800116c:	200000d0 	.word	0x200000d0

08001170 <xTaskPriorityDisinherit>:
        if( pxMutexHolder != NULL )
 8001170:	2800      	cmp	r0, #0
 8001172:	d051      	beq.n	8001218 <xTaskPriorityDisinherit+0xa8>
    {
 8001174:	b570      	push	{r4, r5, r6, lr}
 8001176:	4604      	mov	r4, r0
            configASSERT( pxTCB == pxCurrentTCB );
 8001178:	4b29      	ldr	r3, [pc, #164]	; (8001220 <xTaskPriorityDisinherit+0xb0>)
 800117a:	681b      	ldr	r3, [r3, #0]
 800117c:	4283      	cmp	r3, r0
 800117e:	d008      	beq.n	8001192 <xTaskPriorityDisinherit+0x22>
 8001180:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001184:	f383 8811 	msr	BASEPRI, r3
 8001188:	f3bf 8f6f 	isb	sy
 800118c:	f3bf 8f4f 	dsb	sy
 8001190:	e7fe      	b.n	8001190 <xTaskPriorityDisinherit+0x20>
            configASSERT( pxTCB->uxMutexesHeld );
 8001192:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 8001194:	b943      	cbnz	r3, 80011a8 <xTaskPriorityDisinherit+0x38>
 8001196:	f04f 0350 	mov.w	r3, #80	; 0x50
 800119a:	f383 8811 	msr	BASEPRI, r3
 800119e:	f3bf 8f6f 	isb	sy
 80011a2:	f3bf 8f4f 	dsb	sy
 80011a6:	e7fe      	b.n	80011a6 <xTaskPriorityDisinherit+0x36>
            ( pxTCB->uxMutexesHeld )--;
 80011a8:	3b01      	subs	r3, #1
 80011aa:	64c3      	str	r3, [r0, #76]	; 0x4c
            if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 80011ac:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
 80011ae:	6c82      	ldr	r2, [r0, #72]	; 0x48
 80011b0:	4291      	cmp	r1, r2
 80011b2:	d033      	beq.n	800121c <xTaskPriorityDisinherit+0xac>
                if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 80011b4:	b10b      	cbz	r3, 80011ba <xTaskPriorityDisinherit+0x4a>
        BaseType_t xReturn = pdFALSE;
 80011b6:	2000      	movs	r0, #0
    }
 80011b8:	bd70      	pop	{r4, r5, r6, pc}
                    if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80011ba:	1d05      	adds	r5, r0, #4
 80011bc:	4628      	mov	r0, r5
 80011be:	f7fe ff66 	bl	800008e <uxListRemove>
 80011c2:	b938      	cbnz	r0, 80011d4 <xTaskPriorityDisinherit+0x64>
                        portRESET_READY_PRIORITY( pxTCB->uxPriority, uxTopReadyPriority );
 80011c4:	4917      	ldr	r1, [pc, #92]	; (8001224 <xTaskPriorityDisinherit+0xb4>)
 80011c6:	680b      	ldr	r3, [r1, #0]
 80011c8:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 80011ca:	2201      	movs	r2, #1
 80011cc:	4082      	lsls	r2, r0
 80011ce:	ea23 0302 	bic.w	r3, r3, r2
 80011d2:	600b      	str	r3, [r1, #0]
                    pxTCB->uxPriority = pxTCB->uxBasePriority;
 80011d4:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 80011d6:	62e3      	str	r3, [r4, #44]	; 0x2c
                    listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80011d8:	f1c3 0205 	rsb	r2, r3, #5
 80011dc:	61a2      	str	r2, [r4, #24]
                    prvAddTaskToReadyList( pxTCB );
 80011de:	4911      	ldr	r1, [pc, #68]	; (8001224 <xTaskPriorityDisinherit+0xb4>)
 80011e0:	680e      	ldr	r6, [r1, #0]
 80011e2:	2001      	movs	r0, #1
 80011e4:	fa00 f203 	lsl.w	r2, r0, r3
 80011e8:	4332      	orrs	r2, r6
 80011ea:	600a      	str	r2, [r1, #0]
 80011ec:	4a0e      	ldr	r2, [pc, #56]	; (8001228 <xTaskPriorityDisinherit+0xb8>)
 80011ee:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80011f2:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 80011f6:	685b      	ldr	r3, [r3, #4]
 80011f8:	60a3      	str	r3, [r4, #8]
 80011fa:	6899      	ldr	r1, [r3, #8]
 80011fc:	60e1      	str	r1, [r4, #12]
 80011fe:	604d      	str	r5, [r1, #4]
 8001200:	609d      	str	r5, [r3, #8]
 8001202:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8001204:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 8001208:	008d      	lsls	r5, r1, #2
 800120a:	eb02 0181 	add.w	r1, r2, r1, lsl #2
 800120e:	6161      	str	r1, [r4, #20]
 8001210:	5951      	ldr	r1, [r2, r5]
 8001212:	4401      	add	r1, r0
 8001214:	5151      	str	r1, [r2, r5]
                    xReturn = pdTRUE;
 8001216:	e7cf      	b.n	80011b8 <xTaskPriorityDisinherit+0x48>
        BaseType_t xReturn = pdFALSE;
 8001218:	2000      	movs	r0, #0
    }
 800121a:	4770      	bx	lr
        BaseType_t xReturn = pdFALSE;
 800121c:	2000      	movs	r0, #0
 800121e:	e7cb      	b.n	80011b8 <xTaskPriorityDisinherit+0x48>
 8001220:	20000050 	.word	0x20000050
 8001224:	200000d8 	.word	0x200000d8
 8001228:	2000005c 	.word	0x2000005c

0800122c <prvInsertTimerInActiveList>:

    static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer,
                                                  const TickType_t xNextExpiryTime,
                                                  const TickType_t xTimeNow,
                                                  const TickType_t xCommandTime )
    {
 800122c:	b508      	push	{r3, lr}
        BaseType_t xProcessTimerNow = pdFALSE;

        listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 800122e:	6041      	str	r1, [r0, #4]
        listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 8001230:	6100      	str	r0, [r0, #16]

        if( xNextExpiryTime <= xTimeNow )
 8001232:	4291      	cmp	r1, r2
 8001234:	d80c      	bhi.n	8001250 <prvInsertTimerInActiveList+0x24>
        {
            /* Has the expiry time elapsed between the command to start/reset a
             * timer was issued, and the time the command was processed? */
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8001236:	1ad2      	subs	r2, r2, r3
 8001238:	6983      	ldr	r3, [r0, #24]
 800123a:	429a      	cmp	r2, r3
 800123c:	d301      	bcc.n	8001242 <prvInsertTimerInActiveList+0x16>
            {
                /* The time between a command being issued and the command being
                 * processed actually exceeds the timers period.  */
                xProcessTimerNow = pdTRUE;
 800123e:	2001      	movs	r0, #1
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
            }
        }

        return xProcessTimerNow;
    }
 8001240:	bd08      	pop	{r3, pc}
                vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 8001242:	1d01      	adds	r1, r0, #4
 8001244:	4b09      	ldr	r3, [pc, #36]	; (800126c <prvInsertTimerInActiveList+0x40>)
 8001246:	6818      	ldr	r0, [r3, #0]
 8001248:	f7fe ff08 	bl	800005c <vListInsert>
        BaseType_t xProcessTimerNow = pdFALSE;
 800124c:	2000      	movs	r0, #0
 800124e:	e7f7      	b.n	8001240 <prvInsertTimerInActiveList+0x14>
            if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 8001250:	429a      	cmp	r2, r3
 8001252:	d201      	bcs.n	8001258 <prvInsertTimerInActiveList+0x2c>
 8001254:	4299      	cmp	r1, r3
 8001256:	d206      	bcs.n	8001266 <prvInsertTimerInActiveList+0x3a>
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 8001258:	1d01      	adds	r1, r0, #4
 800125a:	4b05      	ldr	r3, [pc, #20]	; (8001270 <prvInsertTimerInActiveList+0x44>)
 800125c:	6818      	ldr	r0, [r3, #0]
 800125e:	f7fe fefd 	bl	800005c <vListInsert>
        BaseType_t xProcessTimerNow = pdFALSE;
 8001262:	2000      	movs	r0, #0
 8001264:	e7ec      	b.n	8001240 <prvInsertTimerInActiveList+0x14>
                xProcessTimerNow = pdTRUE;
 8001266:	2001      	movs	r0, #1
        return xProcessTimerNow;
 8001268:	e7ea      	b.n	8001240 <prvInsertTimerInActiveList+0x14>
 800126a:	bf00      	nop
 800126c:	20000160 	.word	0x20000160
 8001270:	2000015c 	.word	0x2000015c

08001274 <prvReloadTimer>:
    {
 8001274:	b570      	push	{r4, r5, r6, lr}
 8001276:	4604      	mov	r4, r0
 8001278:	460d      	mov	r5, r1
 800127a:	4616      	mov	r6, r2
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
 800127c:	e004      	b.n	8001288 <prvReloadTimer+0x14>
            xExpiredTime += pxTimer->xTimerPeriodInTicks;
 800127e:	69a3      	ldr	r3, [r4, #24]
 8001280:	441d      	add	r5, r3
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8001282:	6a23      	ldr	r3, [r4, #32]
 8001284:	4620      	mov	r0, r4
 8001286:	4798      	blx	r3
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
 8001288:	69a1      	ldr	r1, [r4, #24]
 800128a:	462b      	mov	r3, r5
 800128c:	4632      	mov	r2, r6
 800128e:	4429      	add	r1, r5
 8001290:	4620      	mov	r0, r4
 8001292:	f7ff ffcb 	bl	800122c <prvInsertTimerInActiveList>
 8001296:	2800      	cmp	r0, #0
 8001298:	d1f1      	bne.n	800127e <prvReloadTimer+0xa>
    }
 800129a:	bd70      	pop	{r4, r5, r6, pc}

0800129c <prvProcessExpiredTimer>:
    {
 800129c:	b570      	push	{r4, r5, r6, lr}
 800129e:	4605      	mov	r5, r0
 80012a0:	460e      	mov	r6, r1
        Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80012a2:	4b0d      	ldr	r3, [pc, #52]	; (80012d8 <prvProcessExpiredTimer+0x3c>)
 80012a4:	681b      	ldr	r3, [r3, #0]
 80012a6:	68db      	ldr	r3, [r3, #12]
 80012a8:	68dc      	ldr	r4, [r3, #12]
        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 80012aa:	1d20      	adds	r0, r4, #4
 80012ac:	f7fe feef 	bl	800008e <uxListRemove>
        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 80012b0:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
 80012b4:	f013 0f04 	tst.w	r3, #4
 80012b8:	d107      	bne.n	80012ca <prvProcessExpiredTimer+0x2e>
            pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
 80012ba:	f023 0301 	bic.w	r3, r3, #1
 80012be:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 80012c2:	6a23      	ldr	r3, [r4, #32]
 80012c4:	4620      	mov	r0, r4
 80012c6:	4798      	blx	r3
    }
 80012c8:	bd70      	pop	{r4, r5, r6, pc}
            prvReloadTimer( pxTimer, xNextExpireTime, xTimeNow );
 80012ca:	4632      	mov	r2, r6
 80012cc:	4629      	mov	r1, r5
 80012ce:	4620      	mov	r0, r4
 80012d0:	f7ff ffd0 	bl	8001274 <prvReloadTimer>
 80012d4:	e7f5      	b.n	80012c2 <prvProcessExpiredTimer+0x26>
 80012d6:	bf00      	nop
 80012d8:	2000015c 	.word	0x2000015c

080012dc <prvSampleTimeNow>:
    {
 80012dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80012de:	4605      	mov	r5, r0
        xTimeNow = xTaskGetTickCount();
 80012e0:	f7ff fbdc 	bl	8000a9c <xTaskGetTickCount>
 80012e4:	4604      	mov	r4, r0
        if( xTimeNow < xLastTime )
 80012e6:	4b11      	ldr	r3, [pc, #68]	; (800132c <prvSampleTimeNow+0x50>)
 80012e8:	681b      	ldr	r3, [r3, #0]
 80012ea:	4283      	cmp	r3, r0
 80012ec:	d805      	bhi.n	80012fa <prvSampleTimeNow+0x1e>
            *pxTimerListsWereSwitched = pdFALSE;
 80012ee:	2300      	movs	r3, #0
 80012f0:	602b      	str	r3, [r5, #0]
        xLastTime = xTimeNow;
 80012f2:	4b0e      	ldr	r3, [pc, #56]	; (800132c <prvSampleTimeNow+0x50>)
 80012f4:	601c      	str	r4, [r3, #0]
    }
 80012f6:	4620      	mov	r0, r4
 80012f8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

        /* The tick count has overflowed.  The timer lists must be switched.
         * If there are any timers still referenced from the current timer list
         * then they must have expired and should be processed before the lists
         * are switched. */
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 80012fa:	4b0d      	ldr	r3, [pc, #52]	; (8001330 <prvSampleTimeNow+0x54>)
 80012fc:	681b      	ldr	r3, [r3, #0]
 80012fe:	681a      	ldr	r2, [r3, #0]
 8001300:	b15a      	cbz	r2, 800131a <prvSampleTimeNow+0x3e>
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );

            /* Process the expired timer.  For auto-reload timers, be careful to
             * process only expirations that occur on the current list.  Further
             * expirations must wait until after the lists are switched. */
            prvProcessExpiredTimer( xNextExpireTime, tmrMAX_TIME_BEFORE_OVERFLOW );
 8001302:	f04f 37ff 	mov.w	r7, #4294967295
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 8001306:	4e0a      	ldr	r6, [pc, #40]	; (8001330 <prvSampleTimeNow+0x54>)
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8001308:	68db      	ldr	r3, [r3, #12]
            prvProcessExpiredTimer( xNextExpireTime, tmrMAX_TIME_BEFORE_OVERFLOW );
 800130a:	4639      	mov	r1, r7
 800130c:	6818      	ldr	r0, [r3, #0]
 800130e:	f7ff ffc5 	bl	800129c <prvProcessExpiredTimer>
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 8001312:	6833      	ldr	r3, [r6, #0]
 8001314:	681a      	ldr	r2, [r3, #0]
 8001316:	2a00      	cmp	r2, #0
 8001318:	d1f6      	bne.n	8001308 <prvSampleTimeNow+0x2c>
        }

        pxTemp = pxCurrentTimerList;
        pxCurrentTimerList = pxOverflowTimerList;
 800131a:	4a06      	ldr	r2, [pc, #24]	; (8001334 <prvSampleTimeNow+0x58>)
 800131c:	6810      	ldr	r0, [r2, #0]
 800131e:	4904      	ldr	r1, [pc, #16]	; (8001330 <prvSampleTimeNow+0x54>)
 8001320:	6008      	str	r0, [r1, #0]
        pxOverflowTimerList = pxTemp;
 8001322:	6013      	str	r3, [r2, #0]
            *pxTimerListsWereSwitched = pdTRUE;
 8001324:	2301      	movs	r3, #1
 8001326:	602b      	str	r3, [r5, #0]
 8001328:	e7e3      	b.n	80012f2 <prvSampleTimeNow+0x16>
 800132a:	bf00      	nop
 800132c:	200001c8 	.word	0x200001c8
 8001330:	2000015c 	.word	0x2000015c
 8001334:	20000160 	.word	0x20000160

08001338 <prvTimerTask>:
    {
 8001338:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800133c:	b084      	sub	sp, #16
        *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 800133e:	4f56      	ldr	r7, [pc, #344]	; (8001498 <prvTimerTask+0x160>)
                    vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
 8001340:	4d56      	ldr	r5, [pc, #344]	; (800149c <prvTimerTask+0x164>)
        *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 8001342:	683b      	ldr	r3, [r7, #0]
 8001344:	681e      	ldr	r6, [r3, #0]
        if( *pxListWasEmpty == pdFALSE )
 8001346:	b196      	cbz	r6, 800136e <prvTimerTask+0x36>
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 8001348:	68db      	ldr	r3, [r3, #12]
 800134a:	681e      	ldr	r6, [r3, #0]
        vTaskSuspendAll();
 800134c:	f7ff fb9e 	bl	8000a8c <vTaskSuspendAll>
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 8001350:	a801      	add	r0, sp, #4
 8001352:	f7ff ffc3 	bl	80012dc <prvSampleTimeNow>
 8001356:	4604      	mov	r4, r0
            if( xTimerListsWereSwitched == pdFALSE )
 8001358:	9a01      	ldr	r2, [sp, #4]
 800135a:	bb42      	cbnz	r2, 80013ae <prvTimerTask+0x76>
                if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 800135c:	42b0      	cmp	r0, r6
 800135e:	d314      	bcc.n	800138a <prvTimerTask+0x52>
                    ( void ) xTaskResumeAll();
 8001360:	f7ff fc7c 	bl	8000c5c <xTaskResumeAll>
                    prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
 8001364:	4621      	mov	r1, r4
 8001366:	4630      	mov	r0, r6
 8001368:	f7ff ff98 	bl	800129c <prvProcessExpiredTimer>
 800136c:	e021      	b.n	80013b2 <prvTimerTask+0x7a>
        vTaskSuspendAll();
 800136e:	f7ff fb8d 	bl	8000a8c <vTaskSuspendAll>
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 8001372:	a801      	add	r0, sp, #4
 8001374:	f7ff ffb2 	bl	80012dc <prvSampleTimeNow>
 8001378:	4604      	mov	r4, r0
            if( xTimerListsWereSwitched == pdFALSE )
 800137a:	9b01      	ldr	r3, [sp, #4]
 800137c:	b9bb      	cbnz	r3, 80013ae <prvTimerTask+0x76>
                        xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 800137e:	4b48      	ldr	r3, [pc, #288]	; (80014a0 <prvTimerTask+0x168>)
 8001380:	681b      	ldr	r3, [r3, #0]
 8001382:	681a      	ldr	r2, [r3, #0]
 8001384:	fab2 f282 	clz	r2, r2
 8001388:	0952      	lsrs	r2, r2, #5
                    vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
 800138a:	1b31      	subs	r1, r6, r4
 800138c:	6828      	ldr	r0, [r5, #0]
 800138e:	f7ff f8eb 	bl	8000568 <vQueueWaitForMessageRestricted>
                    if( xTaskResumeAll() == pdFALSE )
 8001392:	f7ff fc63 	bl	8000c5c <xTaskResumeAll>
 8001396:	b960      	cbnz	r0, 80013b2 <prvTimerTask+0x7a>
                        portYIELD_WITHIN_API();
 8001398:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 800139c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80013a0:	f8c3 2d04 	str.w	r2, [r3, #3332]	; 0xd04
 80013a4:	f3bf 8f4f 	dsb	sy
 80013a8:	f3bf 8f6f 	isb	sy
 80013ac:	e001      	b.n	80013b2 <prvTimerTask+0x7a>
                ( void ) xTaskResumeAll();
 80013ae:	f7ff fc55 	bl	8000c5c <xTaskResumeAll>
        while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 80013b2:	2400      	movs	r4, #0
 80013b4:	4622      	mov	r2, r4
 80013b6:	a901      	add	r1, sp, #4
 80013b8:	6828      	ldr	r0, [r5, #0]
 80013ba:	f7fe fff9 	bl	80003b0 <xQueueReceive>
 80013be:	2800      	cmp	r0, #0
 80013c0:	d0bf      	beq.n	8001342 <prvTimerTask+0xa>
            if( xMessage.xMessageID >= ( BaseType_t ) 0 )
 80013c2:	9b01      	ldr	r3, [sp, #4]
 80013c4:	2b00      	cmp	r3, #0
 80013c6:	dbf5      	blt.n	80013b4 <prvTimerTask+0x7c>
                pxTimer = xMessage.u.xTimerParameters.pxTimer;
 80013c8:	9e03      	ldr	r6, [sp, #12]
                if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
 80013ca:	6973      	ldr	r3, [r6, #20]
 80013cc:	b113      	cbz	r3, 80013d4 <prvTimerTask+0x9c>
                    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 80013ce:	1d30      	adds	r0, r6, #4
 80013d0:	f7fe fe5d 	bl	800008e <uxListRemove>
                xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 80013d4:	4668      	mov	r0, sp
 80013d6:	f7ff ff81 	bl	80012dc <prvSampleTimeNow>
 80013da:	4680      	mov	r8, r0
                switch( xMessage.xMessageID )
 80013dc:	9b01      	ldr	r3, [sp, #4]
 80013de:	3b01      	subs	r3, #1
 80013e0:	2b08      	cmp	r3, #8
 80013e2:	d8e7      	bhi.n	80013b4 <prvTimerTask+0x7c>
 80013e4:	e8df f003 	tbb	[pc, r3]
 80013e8:	30290505 	.word	0x30290505
 80013ec:	29050549 	.word	0x29050549
 80013f0:	30          	.byte	0x30
 80013f1:	00          	.byte	0x00
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 80013f2:	f896 3028 	ldrb.w	r3, [r6, #40]	; 0x28
 80013f6:	f043 0301 	orr.w	r3, r3, #1
 80013fa:	f886 3028 	strb.w	r3, [r6, #40]	; 0x28
                        if( prvInsertTimerInActiveList( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
 80013fe:	9b02      	ldr	r3, [sp, #8]
 8001400:	69b1      	ldr	r1, [r6, #24]
 8001402:	4602      	mov	r2, r0
 8001404:	4419      	add	r1, r3
 8001406:	4630      	mov	r0, r6
 8001408:	f7ff ff10 	bl	800122c <prvInsertTimerInActiveList>
 800140c:	2800      	cmp	r0, #0
 800140e:	d0d1      	beq.n	80013b4 <prvTimerTask+0x7c>
                            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 8001410:	f896 3028 	ldrb.w	r3, [r6, #40]	; 0x28
 8001414:	f013 0f04 	tst.w	r3, #4
 8001418:	d107      	bne.n	800142a <prvTimerTask+0xf2>
                                pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
 800141a:	f023 0301 	bic.w	r3, r3, #1
 800141e:	f886 3028 	strb.w	r3, [r6, #40]	; 0x28
                            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 8001422:	6a33      	ldr	r3, [r6, #32]
 8001424:	4630      	mov	r0, r6
 8001426:	4798      	blx	r3
 8001428:	e7c4      	b.n	80013b4 <prvTimerTask+0x7c>
                                prvReloadTimer( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow );
 800142a:	69b3      	ldr	r3, [r6, #24]
 800142c:	4642      	mov	r2, r8
 800142e:	9902      	ldr	r1, [sp, #8]
 8001430:	4419      	add	r1, r3
 8001432:	4630      	mov	r0, r6
 8001434:	f7ff ff1e 	bl	8001274 <prvReloadTimer>
 8001438:	e7f3      	b.n	8001422 <prvTimerTask+0xea>
                        pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
 800143a:	f896 3028 	ldrb.w	r3, [r6, #40]	; 0x28
 800143e:	f023 0301 	bic.w	r3, r3, #1
 8001442:	f886 3028 	strb.w	r3, [r6, #40]	; 0x28
                        break;
 8001446:	e7b5      	b.n	80013b4 <prvTimerTask+0x7c>
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 8001448:	f896 3028 	ldrb.w	r3, [r6, #40]	; 0x28
 800144c:	f043 0301 	orr.w	r3, r3, #1
 8001450:	f886 3028 	strb.w	r3, [r6, #40]	; 0x28
                        pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 8001454:	9902      	ldr	r1, [sp, #8]
 8001456:	61b1      	str	r1, [r6, #24]
                        configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 8001458:	b131      	cbz	r1, 8001468 <prvTimerTask+0x130>
                        ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
 800145a:	4603      	mov	r3, r0
 800145c:	4602      	mov	r2, r0
 800145e:	4401      	add	r1, r0
 8001460:	4630      	mov	r0, r6
 8001462:	f7ff fee3 	bl	800122c <prvInsertTimerInActiveList>
                        break;
 8001466:	e7a5      	b.n	80013b4 <prvTimerTask+0x7c>
 8001468:	f04f 0350 	mov.w	r3, #80	; 0x50
 800146c:	f383 8811 	msr	BASEPRI, r3
 8001470:	f3bf 8f6f 	isb	sy
 8001474:	f3bf 8f4f 	dsb	sy
                        configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 8001478:	e7fe      	b.n	8001478 <prvTimerTask+0x140>
                                if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
 800147a:	f896 3028 	ldrb.w	r3, [r6, #40]	; 0x28
 800147e:	f013 0f02 	tst.w	r3, #2
 8001482:	d004      	beq.n	800148e <prvTimerTask+0x156>
                                    pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
 8001484:	f023 0301 	bic.w	r3, r3, #1
 8001488:	f886 3028 	strb.w	r3, [r6, #40]	; 0x28
 800148c:	e792      	b.n	80013b4 <prvTimerTask+0x7c>
                                    vPortFree( pxTimer );
 800148e:	4630      	mov	r0, r6
 8001490:	f000 fa68 	bl	8001964 <vPortFree>
 8001494:	e78e      	b.n	80013b4 <prvTimerTask+0x7c>
 8001496:	bf00      	nop
 8001498:	2000015c 	.word	0x2000015c
 800149c:	20000220 	.word	0x20000220
 80014a0:	20000160 	.word	0x20000160

080014a4 <prvCheckForValidListAndQueue>:
    }
/*-----------------------------------------------------------*/

    static void prvCheckForValidListAndQueue( void )
    {
 80014a4:	b530      	push	{r4, r5, lr}
 80014a6:	b083      	sub	sp, #12
        /* Check that the list from which active timers are referenced, and the
         * queue used to communicate with the timer service, have been
         * initialised. */
        taskENTER_CRITICAL();
 80014a8:	f000 f8ba 	bl	8001620 <vPortEnterCritical>
        {
            if( xTimerQueue == NULL )
 80014ac:	4b11      	ldr	r3, [pc, #68]	; (80014f4 <prvCheckForValidListAndQueue+0x50>)
 80014ae:	681b      	ldr	r3, [r3, #0]
 80014b0:	b11b      	cbz	r3, 80014ba <prvCheckForValidListAndQueue+0x16>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
 80014b2:	f000 f8d7 	bl	8001664 <vPortExitCritical>
    }
 80014b6:	b003      	add	sp, #12
 80014b8:	bd30      	pop	{r4, r5, pc}
                vListInitialise( &xActiveTimerList1 );
 80014ba:	4d0f      	ldr	r5, [pc, #60]	; (80014f8 <prvCheckForValidListAndQueue+0x54>)
 80014bc:	4628      	mov	r0, r5
 80014be:	f7fe fdbf 	bl	8000040 <vListInitialise>
                vListInitialise( &xActiveTimerList2 );
 80014c2:	4c0e      	ldr	r4, [pc, #56]	; (80014fc <prvCheckForValidListAndQueue+0x58>)
 80014c4:	4620      	mov	r0, r4
 80014c6:	f7fe fdbb 	bl	8000040 <vListInitialise>
                pxCurrentTimerList = &xActiveTimerList1;
 80014ca:	4b0d      	ldr	r3, [pc, #52]	; (8001500 <prvCheckForValidListAndQueue+0x5c>)
 80014cc:	601d      	str	r5, [r3, #0]
                pxOverflowTimerList = &xActiveTimerList2;
 80014ce:	4b0d      	ldr	r3, [pc, #52]	; (8001504 <prvCheckForValidListAndQueue+0x60>)
 80014d0:	601c      	str	r4, [r3, #0]
                        xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
 80014d2:	2300      	movs	r3, #0
 80014d4:	9300      	str	r3, [sp, #0]
 80014d6:	4b0c      	ldr	r3, [pc, #48]	; (8001508 <prvCheckForValidListAndQueue+0x64>)
 80014d8:	4a0c      	ldr	r2, [pc, #48]	; (800150c <prvCheckForValidListAndQueue+0x68>)
 80014da:	210c      	movs	r1, #12
 80014dc:	2005      	movs	r0, #5
 80014de:	f7fe ff1f 	bl	8000320 <xQueueGenericCreateStatic>
 80014e2:	4b04      	ldr	r3, [pc, #16]	; (80014f4 <prvCheckForValidListAndQueue+0x50>)
 80014e4:	6018      	str	r0, [r3, #0]
                        if( xTimerQueue != NULL )
 80014e6:	2800      	cmp	r0, #0
 80014e8:	d0e3      	beq.n	80014b2 <prvCheckForValidListAndQueue+0xe>
                            vQueueAddToRegistry( xTimerQueue, "TmrQ" );
 80014ea:	4909      	ldr	r1, [pc, #36]	; (8001510 <prvCheckForValidListAndQueue+0x6c>)
 80014ec:	f7ff f812 	bl	8000514 <vQueueAddToRegistry>
 80014f0:	e7df      	b.n	80014b2 <prvCheckForValidListAndQueue+0xe>
 80014f2:	bf00      	nop
 80014f4:	20000220 	.word	0x20000220
 80014f8:	200001a0 	.word	0x200001a0
 80014fc:	200001b4 	.word	0x200001b4
 8001500:	2000015c 	.word	0x2000015c
 8001504:	20000160 	.word	0x20000160
 8001508:	200001cc 	.word	0x200001cc
 800150c:	20000164 	.word	0x20000164
 8001510:	08001ee4 	.word	0x08001ee4

08001514 <xTimerCreateTimerTask>:
    {
 8001514:	b510      	push	{r4, lr}
 8001516:	b088      	sub	sp, #32
        prvCheckForValidListAndQueue();
 8001518:	f7ff ffc4 	bl	80014a4 <prvCheckForValidListAndQueue>
        if( xTimerQueue != NULL )
 800151c:	4b12      	ldr	r3, [pc, #72]	; (8001568 <xTimerCreateTimerTask+0x54>)
 800151e:	681b      	ldr	r3, [r3, #0]
 8001520:	b1cb      	cbz	r3, 8001556 <xTimerCreateTimerTask+0x42>
                    StaticTask_t * pxTimerTaskTCBBuffer = NULL;
 8001522:	2400      	movs	r4, #0
 8001524:	9405      	str	r4, [sp, #20]
                    StackType_t * pxTimerTaskStackBuffer = NULL;
 8001526:	9406      	str	r4, [sp, #24]
                    vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize );
 8001528:	aa07      	add	r2, sp, #28
 800152a:	a906      	add	r1, sp, #24
 800152c:	a805      	add	r0, sp, #20
 800152e:	f000 fad5 	bl	8001adc <vApplicationGetTimerTaskMemory>
                    xTimerTaskHandle = xTaskCreateStatic( prvTimerTask,
 8001532:	9b05      	ldr	r3, [sp, #20]
 8001534:	9302      	str	r3, [sp, #8]
 8001536:	9b06      	ldr	r3, [sp, #24]
 8001538:	9301      	str	r3, [sp, #4]
 800153a:	2302      	movs	r3, #2
 800153c:	9300      	str	r3, [sp, #0]
 800153e:	4623      	mov	r3, r4
 8001540:	9a07      	ldr	r2, [sp, #28]
 8001542:	490a      	ldr	r1, [pc, #40]	; (800156c <xTimerCreateTimerTask+0x58>)
 8001544:	480a      	ldr	r0, [pc, #40]	; (8001570 <xTimerCreateTimerTask+0x5c>)
 8001546:	f7ff f9e5 	bl	8000914 <xTaskCreateStatic>
 800154a:	4b0a      	ldr	r3, [pc, #40]	; (8001574 <xTimerCreateTimerTask+0x60>)
 800154c:	6018      	str	r0, [r3, #0]
                    if( xTimerTaskHandle != NULL )
 800154e:	b110      	cbz	r0, 8001556 <xTimerCreateTimerTask+0x42>
    }
 8001550:	2001      	movs	r0, #1
 8001552:	b008      	add	sp, #32
 8001554:	bd10      	pop	{r4, pc}
 8001556:	f04f 0350 	mov.w	r3, #80	; 0x50
 800155a:	f383 8811 	msr	BASEPRI, r3
 800155e:	f3bf 8f6f 	isb	sy
 8001562:	f3bf 8f4f 	dsb	sy
        configASSERT( xReturn );
 8001566:	e7fe      	b.n	8001566 <xTimerCreateTimerTask+0x52>
 8001568:	20000220 	.word	0x20000220
 800156c:	08001eec 	.word	0x08001eec
 8001570:	08001339 	.word	0x08001339
 8001574:	20000224 	.word	0x20000224

08001578 <prvTaskExitError>:
    return pxTopOfStack;
}
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
 8001578:	b082      	sub	sp, #8
    volatile uint32_t ulDummy = 0;
 800157a:	2300      	movs	r3, #0
 800157c:	9301      	str	r3, [sp, #4]
     * its caller as there is nothing to return to.  If a task wants to exit it
     * should instead call vTaskDelete( NULL ).
     *
     * Artificially force an assert() to be triggered if configASSERT() is
     * defined, then stop here so application writers can catch the error. */
    configASSERT( uxCriticalNesting == ~0UL );
 800157e:	4b0d      	ldr	r3, [pc, #52]	; (80015b4 <prvTaskExitError+0x3c>)
 8001580:	681b      	ldr	r3, [r3, #0]
 8001582:	f1b3 3fff 	cmp.w	r3, #4294967295
 8001586:	d008      	beq.n	800159a <prvTaskExitError+0x22>

    portFORCE_INLINE static void vPortRaiseBASEPRI( void )
    {
        uint32_t ulNewBASEPRI;

        __asm volatile
 8001588:	f04f 0350 	mov.w	r3, #80	; 0x50
 800158c:	f383 8811 	msr	BASEPRI, r3
 8001590:	f3bf 8f6f 	isb	sy
 8001594:	f3bf 8f4f 	dsb	sy
 8001598:	e7fe      	b.n	8001598 <prvTaskExitError+0x20>
 800159a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800159e:	f383 8811 	msr	BASEPRI, r3
 80015a2:	f3bf 8f6f 	isb	sy
 80015a6:	f3bf 8f4f 	dsb	sy
    portDISABLE_INTERRUPTS();

    while( ulDummy == 0 )
 80015aa:	9b01      	ldr	r3, [sp, #4]
 80015ac:	2b00      	cmp	r3, #0
 80015ae:	d0fc      	beq.n	80015aa <prvTaskExitError+0x32>
         * about code appearing after this function is called - making ulDummy
         * volatile makes the compiler think the function could return and
         * therefore not output an 'unreachable code' warning for code that appears
         * after it. */
    }
}
 80015b0:	b002      	add	sp, #8
 80015b2:	4770      	bx	lr
 80015b4:	20000004 	.word	0x20000004

080015b8 <prvPortStartFirstTask>:
{
    /* Start the first task.  This also clears the bit that indicates the FPU is
     * in use in case the FPU was used before the scheduler was started - which
     * would otherwise result in the unnecessary leaving of space in the SVC stack
     * for lazy saving of FPU registers. */
    __asm volatile (
 80015b8:	4808      	ldr	r0, [pc, #32]	; (80015dc <prvPortStartFirstTask+0x24>)
 80015ba:	6800      	ldr	r0, [r0, #0]
 80015bc:	6800      	ldr	r0, [r0, #0]
 80015be:	f380 8808 	msr	MSP, r0
 80015c2:	f04f 0000 	mov.w	r0, #0
 80015c6:	f380 8814 	msr	CONTROL, r0
 80015ca:	b662      	cpsie	i
 80015cc:	b661      	cpsie	f
 80015ce:	f3bf 8f4f 	dsb	sy
 80015d2:	f3bf 8f6f 	isb	sy
 80015d6:	df00      	svc	0
 80015d8:	bf00      	nop
 80015da:	0000      	.short	0x0000
 80015dc:	e000ed08 	.word	0xe000ed08

080015e0 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
    __asm volatile
 80015e0:	f8df 000c 	ldr.w	r0, [pc, #12]	; 80015f0 <vPortEnableVFP+0x10>
 80015e4:	6801      	ldr	r1, [r0, #0]
 80015e6:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80015ea:	6001      	str	r1, [r0, #0]
 80015ec:	4770      	bx	lr
 80015ee:	0000      	.short	0x0000
 80015f0:	e000ed88 	.word	0xe000ed88

080015f4 <pxPortInitialiseStack>:
    *pxTopOfStack = portINITIAL_XPSR;                                    /* xPSR */
 80015f4:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 80015f8:	f840 3c04 	str.w	r3, [r0, #-4]
    *pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK; /* PC */
 80015fc:	f021 0101 	bic.w	r1, r1, #1
 8001600:	f840 1c08 	str.w	r1, [r0, #-8]
    *pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;             /* LR */
 8001604:	4b05      	ldr	r3, [pc, #20]	; (800161c <pxPortInitialiseStack+0x28>)
 8001606:	f840 3c0c 	str.w	r3, [r0, #-12]
    *pxTopOfStack = ( StackType_t ) pvParameters; /* R0 */
 800160a:	f840 2c20 	str.w	r2, [r0, #-32]
    *pxTopOfStack = portINITIAL_EXC_RETURN;
 800160e:	f06f 0302 	mvn.w	r3, #2
 8001612:	f840 3c24 	str.w	r3, [r0, #-36]
}
 8001616:	3844      	subs	r0, #68	; 0x44
 8001618:	4770      	bx	lr
 800161a:	bf00      	nop
 800161c:	08001579 	.word	0x08001579

08001620 <vPortEnterCritical>:
 8001620:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001624:	f383 8811 	msr	BASEPRI, r3
 8001628:	f3bf 8f6f 	isb	sy
 800162c:	f3bf 8f4f 	dsb	sy
    uxCriticalNesting++;
 8001630:	4a0b      	ldr	r2, [pc, #44]	; (8001660 <vPortEnterCritical+0x40>)
 8001632:	6813      	ldr	r3, [r2, #0]
 8001634:	3301      	adds	r3, #1
 8001636:	6013      	str	r3, [r2, #0]
    if( uxCriticalNesting == 1 )
 8001638:	2b01      	cmp	r3, #1
 800163a:	d000      	beq.n	800163e <vPortEnterCritical+0x1e>
}
 800163c:	4770      	bx	lr
        configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
 800163e:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8001642:	f8d3 3d04 	ldr.w	r3, [r3, #3332]	; 0xd04
 8001646:	f013 0fff 	tst.w	r3, #255	; 0xff
 800164a:	d0f7      	beq.n	800163c <vPortEnterCritical+0x1c>
 800164c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001650:	f383 8811 	msr	BASEPRI, r3
 8001654:	f3bf 8f6f 	isb	sy
 8001658:	f3bf 8f4f 	dsb	sy
 800165c:	e7fe      	b.n	800165c <vPortEnterCritical+0x3c>
 800165e:	bf00      	nop
 8001660:	20000004 	.word	0x20000004

08001664 <vPortExitCritical>:
    configASSERT( uxCriticalNesting );
 8001664:	4b09      	ldr	r3, [pc, #36]	; (800168c <vPortExitCritical+0x28>)
 8001666:	681b      	ldr	r3, [r3, #0]
 8001668:	b943      	cbnz	r3, 800167c <vPortExitCritical+0x18>
 800166a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800166e:	f383 8811 	msr	BASEPRI, r3
 8001672:	f3bf 8f6f 	isb	sy
 8001676:	f3bf 8f4f 	dsb	sy
 800167a:	e7fe      	b.n	800167a <vPortExitCritical+0x16>
    uxCriticalNesting--;
 800167c:	3b01      	subs	r3, #1
 800167e:	4a03      	ldr	r2, [pc, #12]	; (800168c <vPortExitCritical+0x28>)
 8001680:	6013      	str	r3, [r2, #0]
    if( uxCriticalNesting == 0 )
 8001682:	b90b      	cbnz	r3, 8001688 <vPortExitCritical+0x24>
    }
/*-----------------------------------------------------------*/

    portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
    {
        __asm volatile
 8001684:	f383 8811 	msr	BASEPRI, r3
}
 8001688:	4770      	bx	lr
 800168a:	bf00      	nop
 800168c:	20000004 	.word	0x20000004

08001690 <vPortSetupTimerInterrupt>:
    portNVIC_SYSTICK_CTRL_REG = 0UL;
 8001690:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 8001694:	2200      	movs	r2, #0
 8001696:	611a      	str	r2, [r3, #16]
    portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 8001698:	619a      	str	r2, [r3, #24]
    portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 800169a:	f64b 327f 	movw	r2, #47999	; 0xbb7f
 800169e:	615a      	str	r2, [r3, #20]
    portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 80016a0:	2207      	movs	r2, #7
 80016a2:	611a      	str	r2, [r3, #16]
}
 80016a4:	4770      	bx	lr
	...

080016a8 <xPortStartScheduler>:
    configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
 80016a8:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80016ac:	f8d3 2d00 	ldr.w	r2, [r3, #3328]	; 0xd00
 80016b0:	4b3e      	ldr	r3, [pc, #248]	; (80017ac <xPortStartScheduler+0x104>)
 80016b2:	429a      	cmp	r2, r3
 80016b4:	d03b      	beq.n	800172e <xPortStartScheduler+0x86>
    configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
 80016b6:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80016ba:	f8d3 2d00 	ldr.w	r2, [r3, #3328]	; 0xd00
 80016be:	4b3c      	ldr	r3, [pc, #240]	; (80017b0 <xPortStartScheduler+0x108>)
 80016c0:	429a      	cmp	r2, r3
 80016c2:	d03d      	beq.n	8001740 <xPortStartScheduler+0x98>
{
 80016c4:	b530      	push	{r4, r5, lr}
 80016c6:	b083      	sub	sp, #12
            ulOriginalPriority = *pucFirstUserPriorityRegister;
 80016c8:	4b3a      	ldr	r3, [pc, #232]	; (80017b4 <xPortStartScheduler+0x10c>)
 80016ca:	781a      	ldrb	r2, [r3, #0]
 80016cc:	b2d2      	uxtb	r2, r2
 80016ce:	9201      	str	r2, [sp, #4]
            *pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 80016d0:	22ff      	movs	r2, #255	; 0xff
 80016d2:	701a      	strb	r2, [r3, #0]
            ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 80016d4:	781b      	ldrb	r3, [r3, #0]
 80016d6:	b2db      	uxtb	r3, r3
 80016d8:	f88d 3003 	strb.w	r3, [sp, #3]
            ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 80016dc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80016e0:	f003 0350 	and.w	r3, r3, #80	; 0x50
 80016e4:	4a34      	ldr	r2, [pc, #208]	; (80017b8 <xPortStartScheduler+0x110>)
 80016e6:	7013      	strb	r3, [r2, #0]
            ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 80016e8:	4b34      	ldr	r3, [pc, #208]	; (80017bc <xPortStartScheduler+0x114>)
 80016ea:	2207      	movs	r2, #7
 80016ec:	601a      	str	r2, [r3, #0]
            while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 80016ee:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80016f2:	f013 0f80 	tst.w	r3, #128	; 0x80
 80016f6:	d011      	beq.n	800171c <xPortStartScheduler+0x74>
 80016f8:	2206      	movs	r2, #6
                ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 80016fa:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80016fe:	005b      	lsls	r3, r3, #1
 8001700:	b2db      	uxtb	r3, r3
 8001702:	f88d 3003 	strb.w	r3, [sp, #3]
            while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8001706:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800170a:	4611      	mov	r1, r2
 800170c:	3a01      	subs	r2, #1
 800170e:	f013 0f80 	tst.w	r3, #128	; 0x80
 8001712:	d1f2      	bne.n	80016fa <xPortStartScheduler+0x52>
 8001714:	4b29      	ldr	r3, [pc, #164]	; (80017bc <xPortStartScheduler+0x114>)
 8001716:	6019      	str	r1, [r3, #0]
                    configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
 8001718:	2903      	cmp	r1, #3
 800171a:	d01a      	beq.n	8001752 <xPortStartScheduler+0xaa>
        __asm volatile
 800171c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001720:	f383 8811 	msr	BASEPRI, r3
 8001724:	f3bf 8f6f 	isb	sy
 8001728:	f3bf 8f4f 	dsb	sy
 800172c:	e7fe      	b.n	800172c <xPortStartScheduler+0x84>
 800172e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001732:	f383 8811 	msr	BASEPRI, r3
 8001736:	f3bf 8f6f 	isb	sy
 800173a:	f3bf 8f4f 	dsb	sy
    configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
 800173e:	e7fe      	b.n	800173e <xPortStartScheduler+0x96>
 8001740:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001744:	f383 8811 	msr	BASEPRI, r3
 8001748:	f3bf 8f6f 	isb	sy
 800174c:	f3bf 8f4f 	dsb	sy
    configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
 8001750:	e7fe      	b.n	8001750 <xPortStartScheduler+0xa8>
            ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 8001752:	4b1a      	ldr	r3, [pc, #104]	; (80017bc <xPortStartScheduler+0x114>)
 8001754:	f44f 7240 	mov.w	r2, #768	; 0x300
 8001758:	601a      	str	r2, [r3, #0]
            *pucFirstUserPriorityRegister = ulOriginalPriority;
 800175a:	9b01      	ldr	r3, [sp, #4]
 800175c:	b2db      	uxtb	r3, r3
 800175e:	4a15      	ldr	r2, [pc, #84]	; (80017b4 <xPortStartScheduler+0x10c>)
 8001760:	7013      	strb	r3, [r2, #0]
    portNVIC_SHPR3_REG |= portNVIC_PENDSV_PRI;
 8001762:	f04f 24e0 	mov.w	r4, #3758153728	; 0xe000e000
 8001766:	f8d4 3d20 	ldr.w	r3, [r4, #3360]	; 0xd20
 800176a:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 800176e:	f8c4 3d20 	str.w	r3, [r4, #3360]	; 0xd20
    portNVIC_SHPR3_REG |= portNVIC_SYSTICK_PRI;
 8001772:	f8d4 3d20 	ldr.w	r3, [r4, #3360]	; 0xd20
 8001776:	f043 4370 	orr.w	r3, r3, #4026531840	; 0xf0000000
 800177a:	f8c4 3d20 	str.w	r3, [r4, #3360]	; 0xd20
    vPortSetupTimerInterrupt();
 800177e:	f7ff ff87 	bl	8001690 <vPortSetupTimerInterrupt>
    uxCriticalNesting = 0;
 8001782:	2500      	movs	r5, #0
 8001784:	4b0e      	ldr	r3, [pc, #56]	; (80017c0 <xPortStartScheduler+0x118>)
 8001786:	601d      	str	r5, [r3, #0]
    vPortEnableVFP();
 8001788:	f7ff ff2a 	bl	80015e0 <vPortEnableVFP>
    *( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
 800178c:	f8d4 3f34 	ldr.w	r3, [r4, #3892]	; 0xf34
 8001790:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
 8001794:	f8c4 3f34 	str.w	r3, [r4, #3892]	; 0xf34
    prvPortStartFirstTask();
 8001798:	f7ff ff0e 	bl	80015b8 <prvPortStartFirstTask>
    vTaskSwitchContext();
 800179c:	f7ff fb40 	bl	8000e20 <vTaskSwitchContext>
    prvTaskExitError();
 80017a0:	f7ff feea 	bl	8001578 <prvTaskExitError>
}
 80017a4:	4628      	mov	r0, r5
 80017a6:	b003      	add	sp, #12
 80017a8:	bd30      	pop	{r4, r5, pc}
 80017aa:	bf00      	nop
 80017ac:	410fc271 	.word	0x410fc271
 80017b0:	410fc270 	.word	0x410fc270
 80017b4:	e000e400 	.word	0xe000e400
 80017b8:	20000228 	.word	0x20000228
 80017bc:	2000022c 	.word	0x2000022c
 80017c0:	20000004 	.word	0x20000004

080017c4 <prvInsertBlockIntoFreeList>:
    BlockLink_t * pxIterator;
    uint8_t * puc;

    /* Iterate through the list until a block is found that has a higher address
     * than the block being inserted. */
    for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 80017c4:	4b15      	ldr	r3, [pc, #84]	; (800181c <prvInsertBlockIntoFreeList+0x58>)
 80017c6:	461a      	mov	r2, r3
 80017c8:	681b      	ldr	r3, [r3, #0]
 80017ca:	4283      	cmp	r3, r0
 80017cc:	d3fb      	bcc.n	80017c6 <prvInsertBlockIntoFreeList+0x2>

    /* Do the block being inserted, and the block it is being inserted after
     * make a contiguous block of memory? */
    puc = ( uint8_t * ) pxIterator;

    if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 80017ce:	6851      	ldr	r1, [r2, #4]
 80017d0:	eb02 0c01 	add.w	ip, r2, r1
 80017d4:	4560      	cmp	r0, ip
 80017d6:	d009      	beq.n	80017ec <prvInsertBlockIntoFreeList+0x28>

    /* Do the block being inserted, and the block it is being inserted before
     * make a contiguous block of memory? */
    puc = ( uint8_t * ) pxBlockToInsert;

    if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 80017d8:	6841      	ldr	r1, [r0, #4]
 80017da:	eb00 0c01 	add.w	ip, r0, r1
 80017de:	4563      	cmp	r3, ip
 80017e0:	d009      	beq.n	80017f6 <prvInsertBlockIntoFreeList+0x32>
            pxBlockToInsert->pxNextFreeBlock = pxEnd;
        }
    }
    else
    {
        pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 80017e2:	6003      	str	r3, [r0, #0]

    /* If the block being inserted plugged a gab, so was merged with the block
     * before and the block after, then it's pxNextFreeBlock pointer will have
     * already been set, and should not be set here as that would make it point
     * to itself. */
    if( pxIterator != pxBlockToInsert )
 80017e4:	4290      	cmp	r0, r2
    {
        pxIterator->pxNextFreeBlock = pxBlockToInsert;
 80017e6:	bf18      	it	ne
 80017e8:	6010      	strne	r0, [r2, #0]
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
 80017ea:	4770      	bx	lr
        pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 80017ec:	6840      	ldr	r0, [r0, #4]
 80017ee:	4401      	add	r1, r0
 80017f0:	6051      	str	r1, [r2, #4]
        pxBlockToInsert = pxIterator;
 80017f2:	4610      	mov	r0, r2
 80017f4:	e7f0      	b.n	80017d8 <prvInsertBlockIntoFreeList+0x14>
{
 80017f6:	b410      	push	{r4}
        if( pxIterator->pxNextFreeBlock != pxEnd )
 80017f8:	4c09      	ldr	r4, [pc, #36]	; (8001820 <prvInsertBlockIntoFreeList+0x5c>)
 80017fa:	6824      	ldr	r4, [r4, #0]
 80017fc:	42a3      	cmp	r3, r4
 80017fe:	d00b      	beq.n	8001818 <prvInsertBlockIntoFreeList+0x54>
            pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8001800:	685b      	ldr	r3, [r3, #4]
 8001802:	4419      	add	r1, r3
 8001804:	6041      	str	r1, [r0, #4]
            pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 8001806:	6813      	ldr	r3, [r2, #0]
 8001808:	681b      	ldr	r3, [r3, #0]
 800180a:	6003      	str	r3, [r0, #0]
    if( pxIterator != pxBlockToInsert )
 800180c:	4290      	cmp	r0, r2
        pxIterator->pxNextFreeBlock = pxBlockToInsert;
 800180e:	bf18      	it	ne
 8001810:	6010      	strne	r0, [r2, #0]
    }
}
 8001812:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001816:	4770      	bx	lr
            pxBlockToInsert->pxNextFreeBlock = pxEnd;
 8001818:	6004      	str	r4, [r0, #0]
 800181a:	e7f7      	b.n	800180c <prvInsertBlockIntoFreeList+0x48>
 800181c:	20004248 	.word	0x20004248
 8001820:	20000230 	.word	0x20000230

08001824 <pvPortMalloc>:
{
 8001824:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001826:	4604      	mov	r4, r0
    vTaskSuspendAll();
 8001828:	f7ff f930 	bl	8000a8c <vTaskSuspendAll>
        if( pxEnd == NULL )
 800182c:	4b46      	ldr	r3, [pc, #280]	; (8001948 <pvPortMalloc+0x124>)
 800182e:	681b      	ldr	r3, [r3, #0]
 8001830:	b1d3      	cbz	r3, 8001868 <pvPortMalloc+0x44>
        if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 8001832:	4b46      	ldr	r3, [pc, #280]	; (800194c <pvPortMalloc+0x128>)
 8001834:	681d      	ldr	r5, [r3, #0]
 8001836:	4225      	tst	r5, r4
 8001838:	f040 8081 	bne.w	800193e <pvPortMalloc+0x11a>
            if( ( xWantedSize > 0 ) &&
 800183c:	1e63      	subs	r3, r4, #1
 800183e:	f113 0f0a 	cmn.w	r3, #10
 8001842:	d87c      	bhi.n	800193e <pvPortMalloc+0x11a>
                xWantedSize += xHeapStructSize;
 8001844:	f104 0208 	add.w	r2, r4, #8
                if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 8001848:	f014 0f07 	tst.w	r4, #7
 800184c:	d005      	beq.n	800185a <pvPortMalloc+0x36>
                    if( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) )
 800184e:	f022 0307 	bic.w	r3, r2, #7
 8001852:	3308      	adds	r3, #8
 8001854:	4293      	cmp	r3, r2
 8001856:	d972      	bls.n	800193e <pvPortMalloc+0x11a>
                        xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 8001858:	461a      	mov	r2, r3
            if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 800185a:	4b3d      	ldr	r3, [pc, #244]	; (8001950 <pvPortMalloc+0x12c>)
 800185c:	681e      	ldr	r6, [r3, #0]
 800185e:	4296      	cmp	r6, r2
 8001860:	d36d      	bcc.n	800193e <pvPortMalloc+0x11a>
                pxBlock = xStart.pxNextFreeBlock;
 8001862:	493c      	ldr	r1, [pc, #240]	; (8001954 <pvPortMalloc+0x130>)
 8001864:	680c      	ldr	r4, [r1, #0]
                while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8001866:	e027      	b.n	80018b8 <pvPortMalloc+0x94>
    uxAddress = ( size_t ) ucHeap;
 8001868:	4a3b      	ldr	r2, [pc, #236]	; (8001958 <pvPortMalloc+0x134>)
    if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 800186a:	f012 0f07 	tst.w	r2, #7
 800186e:	d01e      	beq.n	80018ae <pvPortMalloc+0x8a>
        uxAddress += ( portBYTE_ALIGNMENT - 1 );
 8001870:	1dd1      	adds	r1, r2, #7
        uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 8001872:	f021 0107 	bic.w	r1, r1, #7
        xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
 8001876:	f502 4380 	add.w	r3, r2, #16384	; 0x4000
 800187a:	1a5b      	subs	r3, r3, r1
        uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 800187c:	460a      	mov	r2, r1
    xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 800187e:	4835      	ldr	r0, [pc, #212]	; (8001954 <pvPortMalloc+0x130>)
 8001880:	6002      	str	r2, [r0, #0]
    xStart.xBlockSize = ( size_t ) 0;
 8001882:	2100      	movs	r1, #0
 8001884:	6041      	str	r1, [r0, #4]
    uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
 8001886:	4413      	add	r3, r2
    uxAddress -= xHeapStructSize;
 8001888:	3b08      	subs	r3, #8
    uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 800188a:	f023 0307 	bic.w	r3, r3, #7
    pxEnd = ( void * ) uxAddress;
 800188e:	482e      	ldr	r0, [pc, #184]	; (8001948 <pvPortMalloc+0x124>)
 8001890:	6003      	str	r3, [r0, #0]
    pxEnd->xBlockSize = 0;
 8001892:	6059      	str	r1, [r3, #4]
    pxEnd->pxNextFreeBlock = NULL;
 8001894:	6019      	str	r1, [r3, #0]
    pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 8001896:	1a99      	subs	r1, r3, r2
 8001898:	6051      	str	r1, [r2, #4]
    pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 800189a:	6013      	str	r3, [r2, #0]
    xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 800189c:	4b2f      	ldr	r3, [pc, #188]	; (800195c <pvPortMalloc+0x138>)
 800189e:	6019      	str	r1, [r3, #0]
    xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 80018a0:	4b2b      	ldr	r3, [pc, #172]	; (8001950 <pvPortMalloc+0x12c>)
 80018a2:	6019      	str	r1, [r3, #0]
    xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 80018a4:	4b29      	ldr	r3, [pc, #164]	; (800194c <pvPortMalloc+0x128>)
 80018a6:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 80018aa:	601a      	str	r2, [r3, #0]
}
 80018ac:	e7c1      	b.n	8001832 <pvPortMalloc+0xe>
    size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
 80018ae:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 80018b2:	e7e4      	b.n	800187e <pvPortMalloc+0x5a>
 80018b4:	4621      	mov	r1, r4
                    pxBlock = pxBlock->pxNextFreeBlock;
 80018b6:	461c      	mov	r4, r3
                while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 80018b8:	6863      	ldr	r3, [r4, #4]
 80018ba:	4293      	cmp	r3, r2
 80018bc:	d202      	bcs.n	80018c4 <pvPortMalloc+0xa0>
 80018be:	6823      	ldr	r3, [r4, #0]
 80018c0:	2b00      	cmp	r3, #0
 80018c2:	d1f7      	bne.n	80018b4 <pvPortMalloc+0x90>
                if( pxBlock != pxEnd )
 80018c4:	4b20      	ldr	r3, [pc, #128]	; (8001948 <pvPortMalloc+0x124>)
 80018c6:	681b      	ldr	r3, [r3, #0]
 80018c8:	42a3      	cmp	r3, r4
 80018ca:	d038      	beq.n	800193e <pvPortMalloc+0x11a>
                    pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 80018cc:	680f      	ldr	r7, [r1, #0]
 80018ce:	3708      	adds	r7, #8
                    pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 80018d0:	6823      	ldr	r3, [r4, #0]
 80018d2:	600b      	str	r3, [r1, #0]
                    if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 80018d4:	6863      	ldr	r3, [r4, #4]
 80018d6:	1a9b      	subs	r3, r3, r2
 80018d8:	2b10      	cmp	r3, #16
 80018da:	d910      	bls.n	80018fe <pvPortMalloc+0xda>
                        pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 80018dc:	18a0      	adds	r0, r4, r2
                        configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 80018de:	f010 0f07 	tst.w	r0, #7
 80018e2:	d008      	beq.n	80018f6 <pvPortMalloc+0xd2>

    portFORCE_INLINE static void vPortRaiseBASEPRI( void )
    {
        uint32_t ulNewBASEPRI;

        __asm volatile
 80018e4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80018e8:	f383 8811 	msr	BASEPRI, r3
 80018ec:	f3bf 8f6f 	isb	sy
 80018f0:	f3bf 8f4f 	dsb	sy
 80018f4:	e7fe      	b.n	80018f4 <pvPortMalloc+0xd0>
                        pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 80018f6:	6043      	str	r3, [r0, #4]
                        pxBlock->xBlockSize = xWantedSize;
 80018f8:	6062      	str	r2, [r4, #4]
                        prvInsertBlockIntoFreeList( pxNewBlockLink );
 80018fa:	f7ff ff63 	bl	80017c4 <prvInsertBlockIntoFreeList>
                    xFreeBytesRemaining -= pxBlock->xBlockSize;
 80018fe:	6863      	ldr	r3, [r4, #4]
 8001900:	1af6      	subs	r6, r6, r3
 8001902:	4a13      	ldr	r2, [pc, #76]	; (8001950 <pvPortMalloc+0x12c>)
 8001904:	6016      	str	r6, [r2, #0]
                    if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 8001906:	4a15      	ldr	r2, [pc, #84]	; (800195c <pvPortMalloc+0x138>)
 8001908:	6812      	ldr	r2, [r2, #0]
 800190a:	4296      	cmp	r6, r2
                        xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 800190c:	bf3c      	itt	cc
 800190e:	4a13      	ldrcc	r2, [pc, #76]	; (800195c <pvPortMalloc+0x138>)
 8001910:	6016      	strcc	r6, [r2, #0]
                    pxBlock->xBlockSize |= xBlockAllocatedBit;
 8001912:	432b      	orrs	r3, r5
 8001914:	6063      	str	r3, [r4, #4]
                    pxBlock->pxNextFreeBlock = NULL;
 8001916:	2300      	movs	r3, #0
 8001918:	6023      	str	r3, [r4, #0]
                    xNumberOfSuccessfulAllocations++;
 800191a:	4a11      	ldr	r2, [pc, #68]	; (8001960 <pvPortMalloc+0x13c>)
 800191c:	6813      	ldr	r3, [r2, #0]
 800191e:	3301      	adds	r3, #1
 8001920:	6013      	str	r3, [r2, #0]
    ( void ) xTaskResumeAll();
 8001922:	f7ff f99b 	bl	8000c5c <xTaskResumeAll>
    configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 8001926:	f017 0f07 	tst.w	r7, #7
 800192a:	d00b      	beq.n	8001944 <pvPortMalloc+0x120>
 800192c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001930:	f383 8811 	msr	BASEPRI, r3
 8001934:	f3bf 8f6f 	isb	sy
 8001938:	f3bf 8f4f 	dsb	sy
 800193c:	e7fe      	b.n	800193c <pvPortMalloc+0x118>
    ( void ) xTaskResumeAll();
 800193e:	f7ff f98d 	bl	8000c5c <xTaskResumeAll>
 8001942:	2700      	movs	r7, #0
}
 8001944:	4638      	mov	r0, r7
 8001946:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001948:	20000230 	.word	0x20000230
 800194c:	20004234 	.word	0x20004234
 8001950:	20004238 	.word	0x20004238
 8001954:	20004248 	.word	0x20004248
 8001958:	20000234 	.word	0x20000234
 800195c:	2000423c 	.word	0x2000423c
 8001960:	20004240 	.word	0x20004240

08001964 <vPortFree>:
    if( pv != NULL )
 8001964:	2800      	cmp	r0, #0
 8001966:	d033      	beq.n	80019d0 <vPortFree+0x6c>
{
 8001968:	b510      	push	{r4, lr}
 800196a:	4604      	mov	r4, r0
        configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 800196c:	f850 3c04 	ldr.w	r3, [r0, #-4]
 8001970:	4a18      	ldr	r2, [pc, #96]	; (80019d4 <vPortFree+0x70>)
 8001972:	6812      	ldr	r2, [r2, #0]
 8001974:	4213      	tst	r3, r2
 8001976:	d108      	bne.n	800198a <vPortFree+0x26>
 8001978:	f04f 0350 	mov.w	r3, #80	; 0x50
 800197c:	f383 8811 	msr	BASEPRI, r3
 8001980:	f3bf 8f6f 	isb	sy
 8001984:	f3bf 8f4f 	dsb	sy
 8001988:	e7fe      	b.n	8001988 <vPortFree+0x24>
        configASSERT( pxLink->pxNextFreeBlock == NULL );
 800198a:	f850 1c08 	ldr.w	r1, [r0, #-8]
 800198e:	b141      	cbz	r1, 80019a2 <vPortFree+0x3e>
 8001990:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001994:	f383 8811 	msr	BASEPRI, r3
 8001998:	f3bf 8f6f 	isb	sy
 800199c:	f3bf 8f4f 	dsb	sy
 80019a0:	e7fe      	b.n	80019a0 <vPortFree+0x3c>
                pxLink->xBlockSize &= ~xBlockAllocatedBit;
 80019a2:	ea23 0302 	bic.w	r3, r3, r2
 80019a6:	f840 3c04 	str.w	r3, [r0, #-4]
                vTaskSuspendAll();
 80019aa:	f7ff f86f 	bl	8000a8c <vTaskSuspendAll>
                    xFreeBytesRemaining += pxLink->xBlockSize;
 80019ae:	4a0a      	ldr	r2, [pc, #40]	; (80019d8 <vPortFree+0x74>)
 80019b0:	f854 3c04 	ldr.w	r3, [r4, #-4]
 80019b4:	6811      	ldr	r1, [r2, #0]
 80019b6:	440b      	add	r3, r1
 80019b8:	6013      	str	r3, [r2, #0]
                    prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 80019ba:	f1a4 0008 	sub.w	r0, r4, #8
 80019be:	f7ff ff01 	bl	80017c4 <prvInsertBlockIntoFreeList>
                    xNumberOfSuccessfulFrees++;
 80019c2:	4a06      	ldr	r2, [pc, #24]	; (80019dc <vPortFree+0x78>)
 80019c4:	6813      	ldr	r3, [r2, #0]
 80019c6:	3301      	adds	r3, #1
 80019c8:	6013      	str	r3, [r2, #0]
                ( void ) xTaskResumeAll();
 80019ca:	f7ff f947 	bl	8000c5c <xTaskResumeAll>
}
 80019ce:	bd10      	pop	{r4, pc}
 80019d0:	4770      	bx	lr
 80019d2:	bf00      	nop
 80019d4:	20004234 	.word	0x20004234
 80019d8:	20004238 	.word	0x20004238
 80019dc:	20004244 	.word	0x20004244

080019e0 <vTest>:
                  void * pvBuffer,	//     
                  TickType_t xTicksToWait	//        
);


void vTest(void *arg){ // 
 80019e0:	b508      	push	{r3, lr}
	char testDATA[60];
	QUEUE_DATA SPI_COM;
	while(1)
	{

		vTaskDelay(600);
 80019e2:	f44f 7416 	mov.w	r4, #600	; 0x258
 80019e6:	4620      	mov	r0, r4
 80019e8:	f7ff f9f4 	bl	8000dd4 <vTaskDelay>
	while(1)
 80019ec:	e7fb      	b.n	80019e6 <vTest+0x6>

080019ee <LL_GPIO_SetPinMode>:
  *         @arg @ref LL_GPIO_MODE_ALTERNATE
  *         @arg @ref LL_GPIO_MODE_ANALOG
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetPinMode(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Mode)
{
 80019ee:	b410      	push	{r4}
  MODIFY_REG(GPIOx->MODER, (GPIO_MODER_MODE0 << (POSITION_VAL(Pin) * 2U)), (Mode << (POSITION_VAL(Pin) * 2U)));
 80019f0:	6804      	ldr	r4, [r0, #0]
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80019f2:	fa91 f3a1 	rbit	r3, r1
   */
  if (value == 0U)
  {
    return 32U;
  }
  return __builtin_clz(value);
 80019f6:	fab3 f383 	clz	r3, r3
 80019fa:	005b      	lsls	r3, r3, #1
 80019fc:	f04f 0c03 	mov.w	ip, #3
 8001a00:	fa0c f303 	lsl.w	r3, ip, r3
 8001a04:	ea24 0303 	bic.w	r3, r4, r3
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8001a08:	fa91 f1a1 	rbit	r1, r1
  return __builtin_clz(value);
 8001a0c:	fab1 f181 	clz	r1, r1
 8001a10:	0049      	lsls	r1, r1, #1
 8001a12:	fa02 f101 	lsl.w	r1, r2, r1
 8001a16:	4319      	orrs	r1, r3
 8001a18:	6001      	str	r1, [r0, #0]
}
 8001a1a:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001a1e:	4770      	bx	lr

08001a20 <LL_GPIO_SetPinSpeed>:
  *         @arg @ref LL_GPIO_SPEED_FREQ_HIGH
  *         @arg @ref LL_GPIO_SPEED_FREQ_VERY_HIGH
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetPinSpeed(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t  Speed)
{
 8001a20:	b410      	push	{r4}
  MODIFY_REG(GPIOx->OSPEEDR, (GPIO_OSPEEDR_OSPEED0 << (POSITION_VAL(Pin) * 2U)),
 8001a22:	6884      	ldr	r4, [r0, #8]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8001a24:	fa91 f3a1 	rbit	r3, r1
  return __builtin_clz(value);
 8001a28:	fab3 f383 	clz	r3, r3
 8001a2c:	005b      	lsls	r3, r3, #1
 8001a2e:	f04f 0c03 	mov.w	ip, #3
 8001a32:	fa0c f303 	lsl.w	r3, ip, r3
 8001a36:	ea24 0303 	bic.w	r3, r4, r3
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8001a3a:	fa91 f1a1 	rbit	r1, r1
  return __builtin_clz(value);
 8001a3e:	fab1 f181 	clz	r1, r1
 8001a42:	0049      	lsls	r1, r1, #1
 8001a44:	fa02 f101 	lsl.w	r1, r2, r1
 8001a48:	4319      	orrs	r1, r3
 8001a4a:	6081      	str	r1, [r0, #8]
             (Speed << (POSITION_VAL(Pin) * 2U)));
}
 8001a4c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001a50:	4770      	bx	lr

08001a52 <LL_GPIO_SetPinPull>:
  *         @arg @ref LL_GPIO_PULL_UP
  *         @arg @ref LL_GPIO_PULL_DOWN
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetPinPull(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Pull)
{
 8001a52:	b410      	push	{r4}
  MODIFY_REG(GPIOx->PUPDR, (GPIO_PUPDR_PUPD0 << (POSITION_VAL(Pin) * 2U)), (Pull << (POSITION_VAL(Pin) * 2U)));
 8001a54:	68c4      	ldr	r4, [r0, #12]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8001a56:	fa91 f3a1 	rbit	r3, r1
  return __builtin_clz(value);
 8001a5a:	fab3 f383 	clz	r3, r3
 8001a5e:	005b      	lsls	r3, r3, #1
 8001a60:	f04f 0c03 	mov.w	ip, #3
 8001a64:	fa0c f303 	lsl.w	r3, ip, r3
 8001a68:	ea24 0303 	bic.w	r3, r4, r3
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8001a6c:	fa91 f1a1 	rbit	r1, r1
  return __builtin_clz(value);
 8001a70:	fab1 f181 	clz	r1, r1
 8001a74:	0049      	lsls	r1, r1, #1
 8001a76:	fa02 f101 	lsl.w	r1, r2, r1
 8001a7a:	4319      	orrs	r1, r3
 8001a7c:	60c1      	str	r1, [r0, #12]
}
 8001a7e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001a82:	4770      	bx	lr

08001a84 <board_gpio_set_output>:
#define BOARD_BAT2_CONNECT_PIN          LL_GPIO_PIN_9
    #endif

static inline void board_gpio_set_output(GPIO_TypeDef *GPIOx, uint32_t Pin,
		uint32_t Pull, uint32_t Speed)
{
 8001a84:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001a86:	4604      	mov	r4, r0
 8001a88:	460d      	mov	r5, r1
 8001a8a:	4617      	mov	r7, r2
 8001a8c:	461e      	mov	r6, r3
	LL_GPIO_SetPinMode(GPIOx, Pin, LL_GPIO_MODE_OUTPUT);
 8001a8e:	2201      	movs	r2, #1
 8001a90:	f7ff ffad 	bl	80019ee <LL_GPIO_SetPinMode>
  MODIFY_REG(GPIOx->OTYPER, PinMask, (PinMask * OutputType));
 8001a94:	6863      	ldr	r3, [r4, #4]
 8001a96:	ea23 0305 	bic.w	r3, r3, r5
 8001a9a:	6063      	str	r3, [r4, #4]
	LL_GPIO_SetPinOutputType(GPIOx, Pin, LL_GPIO_OUTPUT_PUSHPULL);
	LL_GPIO_SetPinPull(GPIOx, Pin, Pull);
 8001a9c:	463a      	mov	r2, r7
 8001a9e:	4629      	mov	r1, r5
 8001aa0:	4620      	mov	r0, r4
 8001aa2:	f7ff ffd6 	bl	8001a52 <LL_GPIO_SetPinPull>
	LL_GPIO_SetPinSpeed(GPIOx, Pin, Speed);
 8001aa6:	4632      	mov	r2, r6
 8001aa8:	4629      	mov	r1, r5
 8001aaa:	4620      	mov	r0, r4
 8001aac:	f7ff ffb8 	bl	8001a20 <LL_GPIO_SetPinSpeed>
}
 8001ab0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08001ab2 <vApplicationStackOverflowHook>:
 8001ab2:	f04f 0350 	mov.w	r3, #80	; 0x50
 8001ab6:	f383 8811 	msr	BASEPRI, r3
 8001aba:	f3bf 8f6f 	isb	sy
 8001abe:	f3bf 8f4f 	dsb	sy
    configASSERT( NULL );
 8001ac2:	e7fe      	b.n	8001ac2 <vApplicationStackOverflowHook+0x10>

08001ac4 <vApplicationGetIdleTaskMemory>:
  *ppxIdleTaskTCBBuffer = &Idle_TCB;
 8001ac4:	4b03      	ldr	r3, [pc, #12]	; (8001ad4 <vApplicationGetIdleTaskMemory+0x10>)
 8001ac6:	6003      	str	r3, [r0, #0]
  *ppxIdleTaskStackBuffer = Idle_Stack;
 8001ac8:	4b03      	ldr	r3, [pc, #12]	; (8001ad8 <vApplicationGetIdleTaskMemory+0x14>)
 8001aca:	600b      	str	r3, [r1, #0]
  *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
 8001acc:	f44f 7380 	mov.w	r3, #256	; 0x100
 8001ad0:	6013      	str	r3, [r2, #0]
}
 8001ad2:	4770      	bx	lr
 8001ad4:	20004654 	.word	0x20004654
 8001ad8:	20004254 	.word	0x20004254

08001adc <vApplicationGetTimerTaskMemory>:
  *ppxTimerTaskTCBBuffer   = &Timer_TCB;
 8001adc:	4b03      	ldr	r3, [pc, #12]	; (8001aec <vApplicationGetTimerTaskMemory+0x10>)
 8001ade:	6003      	str	r3, [r0, #0]
  *ppxTimerTaskStackBuffer = Timer_Stack;
 8001ae0:	4b03      	ldr	r3, [pc, #12]	; (8001af0 <vApplicationGetTimerTaskMemory+0x14>)
 8001ae2:	600b      	str	r3, [r1, #0]
  *pulTimerTaskStackSize   = configTIMER_TASK_STACK_DEPTH;
 8001ae4:	f44f 7380 	mov.w	r3, #256	; 0x100
 8001ae8:	6013      	str	r3, [r2, #0]
}
 8001aea:	4770      	bx	lr
 8001aec:	20004abc 	.word	0x20004abc
 8001af0:	200046bc 	.word	0x200046bc

08001af4 <main>:

QueueHandle_t xQueue;

volatile uint32_t delay_shuntsNoSleep = 0;
int main(void)
{
 8001af4:	b580      	push	{r7, lr}
 8001af6:	b082      	sub	sp, #8


	clock_init();
 8001af8:	f000 f94c 	bl	8001d94 <clock_init>

//	xQueue = xQueueCreate(5,sizeof(long))		//        long

	xTaskCreate(vTest, "test_task", TASK_START_STK_SIZE, NULL, TASK_PRIO_START, &start_handler);	// 
 8001afc:	4b70      	ldr	r3, [pc, #448]	; (8001cc0 <main+0x1cc>)
 8001afe:	9301      	str	r3, [sp, #4]
 8001b00:	2301      	movs	r3, #1
 8001b02:	9300      	str	r3, [sp, #0]
 8001b04:	2300      	movs	r3, #0
 8001b06:	f44f 7280 	mov.w	r2, #256	; 0x100
 8001b0a:	496e      	ldr	r1, [pc, #440]	; (8001cc4 <main+0x1d0>)
 8001b0c:	486e      	ldr	r0, [pc, #440]	; (8001cc8 <main+0x1d4>)
 8001b0e:	f7fe ff3c 	bl	800098a <xTaskCreate>

	vTaskStartScheduler();	// 
 8001b12:	f7fe ff6d 	bl	80009f0 <vTaskStartScheduler>
  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
 8001b16:	2300      	movs	r3, #0
 8001b18:	f383 8813 	msr	FAULTMASK, r3
	Note: IWDG _must_ be enabled in option bits for production.
	*/
static inline void iwdg_set_2s_reload()
{
	/* enable write access */
	IWDG->KR = 0xCCCC;
 8001b1c:	4b6b      	ldr	r3, [pc, #428]	; (8001ccc <main+0x1d8>)
 8001b1e:	f64c 42cc 	movw	r2, #52428	; 0xcccc
 8001b22:	601a      	str	r2, [r3, #0]
	IWDG->KR = 0x5555;
 8001b24:	f245 5255 	movw	r2, #21845	; 0x5555
 8001b28:	601a      	str	r2, [r3, #0]

    IWDG->RLR = 0xFFF;
 8001b2a:	f640 72ff 	movw	r2, #4095	; 0xfff
 8001b2e:	609a      	str	r2, [r3, #8]

	/* prescaler = 16, timeout = 2.048sec */
	IWDG->PR = IWDG_PR_PR_1;
 8001b30:	2202      	movs	r2, #2
 8001b32:	605a      	str	r2, [r3, #4]

	/* wait for registers to be updated */
	while (IWDG->SR != 0) ;
 8001b34:	461a      	mov	r2, r3
 8001b36:	68d3      	ldr	r3, [r2, #12]
 8001b38:	2b00      	cmp	r3, #0
 8001b3a:	d1fc      	bne.n	8001b36 <main+0x42>

	/* reload counter */
	IWDG->KR = 0xAAAA;
 8001b3c:	4b63      	ldr	r3, [pc, #396]	; (8001ccc <main+0x1d8>)
 8001b3e:	f64a 22aa 	movw	r2, #43690	; 0xaaaa
 8001b42:	601a      	str	r2, [r3, #0]
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8001b44:	4962      	ldr	r1, [pc, #392]	; (8001cd0 <main+0x1dc>)
 8001b46:	68ca      	ldr	r2, [r1, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8001b48:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 8001b4c:	0412      	lsls	r2, r2, #16
 8001b4e:	0c12      	lsrs	r2, r2, #16
  reg_value  =  (reg_value                                   |
 8001b50:	4b60      	ldr	r3, [pc, #384]	; (8001cd4 <main+0x1e0>)
 8001b52:	4313      	orrs	r3, r2
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
  SCB->AIRCR =  reg_value;
 8001b54:	60cb      	str	r3, [r1, #12]

static inline void board_gpio_init()
{
	/* DBG1 */
	board_gpio_set_output(BOARD_DEBUG1_GPIO, BOARD_DEBUG1_PIN, LL_GPIO_PULL_NO, LL_GPIO_SPEED_FREQ_VERY_HIGH);
 8001b56:	2303      	movs	r3, #3
 8001b58:	2200      	movs	r2, #0
 8001b5a:	f44f 7180 	mov.w	r1, #256	; 0x100
 8001b5e:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8001b62:	f7ff ff8f 	bl	8001a84 <board_gpio_set_output>

	/* SPI FLASH Vdd on/off */
	board_gpio_set_output(BOARD_SPI_FLASH_GPIO, BOARD_SPI_FLASH_PIN, LL_GPIO_PULL_NO, LL_GPIO_SPEED_FREQ_LOW);
 8001b66:	4c5c      	ldr	r4, [pc, #368]	; (8001cd8 <main+0x1e4>)
 8001b68:	2300      	movs	r3, #0
 8001b6a:	461a      	mov	r2, r3
 8001b6c:	f44f 7100 	mov.w	r1, #512	; 0x200
 8001b70:	4620      	mov	r0, r4
 8001b72:	f7ff ff87 	bl	8001a84 <board_gpio_set_output>
  *         @arg @ref LL_GPIO_PIN_ALL
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetOutputPin(GPIO_TypeDef *GPIOx, uint32_t PinMask)
{
  WRITE_REG(GPIOx->BSRR, PinMask);
 8001b76:	f44f 7800 	mov.w	r8, #512	; 0x200
 8001b7a:	f8c4 8018 	str.w	r8, [r4, #24]
    LL_GPIO_SetOutputPin(BOARD_SPI_FLASH_GPIO, BOARD_SPI_FLASH_PIN);    // off flash pwr

	/* SPI FLASH CS */
	board_gpio_set_output(BOARD_SPI_FLASH_CS_GPIO, BOARD_SPI_FLASH_CS_PIN, LL_GPIO_PULL_NO, LL_GPIO_SPEED_FREQ_LOW);
 8001b7e:	2300      	movs	r3, #0
 8001b80:	461a      	mov	r2, r3
 8001b82:	2110      	movs	r1, #16
 8001b84:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8001b88:	f7ff ff7c 	bl	8001a84 <board_gpio_set_output>
  *         @arg @ref LL_GPIO_PIN_ALL
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_ResetOutputPin(GPIO_TypeDef *GPIOx, uint32_t PinMask)
{
  WRITE_REG(GPIOx->BRR, PinMask);
 8001b8c:	f04f 4590 	mov.w	r5, #1207959552	; 0x48000000
 8001b90:	2310      	movs	r3, #16
 8001b92:	62ab      	str	r3, [r5, #40]	; 0x28
    LL_GPIO_ResetOutputPin(BOARD_SPI_FLASH_CS_GPIO, BOARD_SPI_FLASH_CS_PIN);    // CS = 0, while flash power is off

    //AXSEM Tx supply
	board_gpio_set_output(BOARD_RADIO_TX_GPIO, BOARD_RADIO_TX_PIN, LL_GPIO_PULL_NO, LL_GPIO_SPEED_FREQ_LOW);
 8001b94:	4e51      	ldr	r6, [pc, #324]	; (8001cdc <main+0x1e8>)
 8001b96:	2300      	movs	r3, #0
 8001b98:	461a      	mov	r2, r3
 8001b9a:	2108      	movs	r1, #8
 8001b9c:	4630      	mov	r0, r6
 8001b9e:	f7ff ff71 	bl	8001a84 <board_gpio_set_output>
 8001ba2:	2708      	movs	r7, #8
 8001ba4:	62b7      	str	r7, [r6, #40]	; 0x28
    LL_GPIO_ResetOutputPin(BOARD_RADIO_TX_GPIO, BOARD_RADIO_TX_PIN);    // off Tx power

	// AXSEM Rx supply
	board_gpio_set_output(BOARD_RADIO_RX_GPIO, BOARD_RADIO_RX_PIN, LL_GPIO_PULL_NO, LL_GPIO_SPEED_FREQ_LOW);
 8001ba6:	f8df 913c 	ldr.w	r9, [pc, #316]	; 8001ce4 <main+0x1f0>
 8001baa:	2300      	movs	r3, #0
 8001bac:	461a      	mov	r2, r3
 8001bae:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8001bb2:	4648      	mov	r0, r9
 8001bb4:	f7ff ff66 	bl	8001a84 <board_gpio_set_output>
  WRITE_REG(GPIOx->BSRR, PinMask);
 8001bb8:	f44f 5600 	mov.w	r6, #8192	; 0x2000
 8001bbc:	f8c9 6018 	str.w	r6, [r9, #24]
    LL_GPIO_SetOutputPin(BOARD_RADIO_RX_GPIO, BOARD_RADIO_RX_PIN);      // off Rx power

	/* AMP1 */
	board_gpio_set_output(BOARD_AMP1_PWR_GPIO, BOARD_AMP1_PWR_PIN, LL_GPIO_PULL_NO, LL_GPIO_SPEED_FREQ_LOW);
 8001bc0:	2300      	movs	r3, #0
 8001bc2:	461a      	mov	r2, r3
 8001bc4:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8001bc8:	4628      	mov	r0, r5
 8001bca:	f7ff ff5b 	bl	8001a84 <board_gpio_set_output>

	/* TMP PWR */
	board_gpio_set_output(BOARD_TEMP_PWR_GPIO, BOARD_TEMP_PWR_PIN, LL_GPIO_PULL_NO, LL_GPIO_SPEED_FREQ_LOW);
 8001bce:	2300      	movs	r3, #0
 8001bd0:	461a      	mov	r2, r3
 8001bd2:	2102      	movs	r1, #2
 8001bd4:	4620      	mov	r0, r4
 8001bd6:	f7ff ff55 	bl	8001a84 <board_gpio_set_output>

	/* LED */
	board_gpio_set_output(BOARD_LED_GPIO, BOARD_LED_PIN, LL_GPIO_PULL_NO, LL_GPIO_SPEED_FREQ_LOW);
 8001bda:	2300      	movs	r3, #0
 8001bdc:	461a      	mov	r2, r3
 8001bde:	f44f 7180 	mov.w	r1, #256	; 0x100
 8001be2:	4620      	mov	r0, r4
 8001be4:	f7ff ff4e 	bl	8001a84 <board_gpio_set_output>

	/* SELECT */
	board_gpio_set_output(BOARD_SELECT_GPIO, BOARD_SELECT_PIN, LL_GPIO_PULL_NO, LL_GPIO_SPEED_FREQ_LOW);
 8001be8:	2300      	movs	r3, #0
 8001bea:	461a      	mov	r2, r3
 8001bec:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8001bf0:	4628      	mov	r0, r5
 8001bf2:	f7ff ff47 	bl	8001a84 <board_gpio_set_output>

	/* TX SENS ENABLE*/
	board_gpio_set_output(BOARD_SENS_TX_EN_GPIO, BOARD_SENS_TX_EN_PIN, LL_GPIO_PULL_NO, LL_GPIO_SPEED_FREQ_LOW);
 8001bf6:	2300      	movs	r3, #0
 8001bf8:	461a      	mov	r2, r3
 8001bfa:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8001bfe:	4620      	mov	r0, r4
 8001c00:	f7ff ff40 	bl	8001a84 <board_gpio_set_output>

	/* SHUNT SENS ENABLE*/
	board_gpio_set_output(BOARD_SENS_SH_EN_GPIO, BOARD_SENS_SH_EN_PIN, LL_GPIO_PULL_NO, LL_GPIO_SPEED_FREQ_LOW);
 8001c04:	2300      	movs	r3, #0
 8001c06:	461a      	mov	r2, r3
 8001c08:	4641      	mov	r1, r8
 8001c0a:	4628      	mov	r0, r5
 8001c0c:	f7ff ff3a 	bl	8001a84 <board_gpio_set_output>

    board_gpio_set_output(BOARD_SENS_SH_2_EN_GPIO, BOARD_SENS_SH_2_EN_PIN, LL_GPIO_PULL_NO, LL_GPIO_SPEED_FREQ_LOW);
 8001c10:	2300      	movs	r3, #0
 8001c12:	461a      	mov	r2, r3
 8001c14:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8001c18:	4628      	mov	r0, r5
 8001c1a:	f7ff ff33 	bl	8001a84 <board_gpio_set_output>

	/* S0L */
	//LL_GPIO_SetPinMode(BOARD_S0L_GPIO, BOARD_S0L_PIN, LL_GPIO_MODE_ALTERNATE);
    LL_GPIO_SetPinMode(BOARD_S0L_GPIO, BOARD_S0L_PIN, LL_GPIO_MODE_OUTPUT);
 8001c1e:	2201      	movs	r2, #1
 8001c20:	4631      	mov	r1, r6
 8001c22:	4620      	mov	r0, r4
 8001c24:	f7ff fee3 	bl	80019ee <LL_GPIO_SetPinMode>
  MODIFY_REG(GPIOx->OTYPER, PinMask, (PinMask * OutputType));
 8001c28:	6863      	ldr	r3, [r4, #4]
 8001c2a:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8001c2e:	6063      	str	r3, [r4, #4]
	LL_GPIO_SetPinOutputType(BOARD_S0L_GPIO, BOARD_S0L_PIN, LL_GPIO_OUTPUT_PUSHPULL);
	//LL_GPIO_SetAFPin_8_15(BOARD_S0L_GPIO, BOARD_S0L_PIN, LL_GPIO_AF_14);
	LL_GPIO_SetPinPull(BOARD_S0L_GPIO, BOARD_S0L_PIN, LL_GPIO_PULL_NO);
 8001c30:	2200      	movs	r2, #0
 8001c32:	4631      	mov	r1, r6
 8001c34:	4620      	mov	r0, r4
 8001c36:	f7ff ff0c 	bl	8001a52 <LL_GPIO_SetPinPull>
	LL_GPIO_SetPinSpeed(BOARD_S0L_GPIO, BOARD_S0L_PIN, LL_GPIO_SPEED_FREQ_LOW);
 8001c3a:	2200      	movs	r2, #0
 8001c3c:	4631      	mov	r1, r6
 8001c3e:	4620      	mov	r0, r4
 8001c40:	f7ff feee 	bl	8001a20 <LL_GPIO_SetPinSpeed>

	/* S0H */
	//LL_GPIO_SetPinMode(BOARD_S0H_GPIO, BOARD_S0H_PIN, LL_GPIO_MODE_ALTERNATE);
    LL_GPIO_SetPinMode(BOARD_S0H_GPIO, BOARD_S0H_PIN, LL_GPIO_MODE_OUTPUT);
 8001c44:	2201      	movs	r2, #1
 8001c46:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 8001c4a:	4620      	mov	r0, r4
 8001c4c:	f7ff fecf 	bl	80019ee <LL_GPIO_SetPinMode>
 8001c50:	6863      	ldr	r3, [r4, #4]
 8001c52:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8001c56:	6063      	str	r3, [r4, #4]
	LL_GPIO_SetPinOutputType(BOARD_S0H_GPIO, BOARD_S0H_PIN, LL_GPIO_OUTPUT_PUSHPULL);
	//LL_GPIO_SetAFPin_8_15(BOARD_S0H_GPIO, BOARD_S0H_PIN, LL_GPIO_AF_14);
	LL_GPIO_SetPinPull(BOARD_S0H_GPIO, BOARD_S0H_PIN, LL_GPIO_PULL_NO);
 8001c58:	2200      	movs	r2, #0
 8001c5a:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 8001c5e:	4620      	mov	r0, r4
 8001c60:	f7ff fef7 	bl	8001a52 <LL_GPIO_SetPinPull>
	LL_GPIO_SetPinSpeed(BOARD_S0H_GPIO, BOARD_S0H_PIN, LL_GPIO_SPEED_FREQ_LOW);
 8001c64:	2200      	movs	r2, #0
 8001c66:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 8001c6a:	4620      	mov	r0, r4
 8001c6c:	f7ff fed8 	bl	8001a20 <LL_GPIO_SetPinSpeed>

    LL_GPIO_SetPinMode(BOARD_ENCOUNT_GPIO, BOARD_ENCOUNT_PIN, LL_GPIO_MODE_INPUT);
 8001c70:	2200      	movs	r2, #0
 8001c72:	4639      	mov	r1, r7
 8001c74:	4620      	mov	r0, r4
 8001c76:	f7ff feba 	bl	80019ee <LL_GPIO_SetPinMode>
    LL_GPIO_SetPinPull(BOARD_ENCOUNT_GPIO, BOARD_ENCOUNT_PIN, LL_GPIO_PULL_NO);
 8001c7a:	2200      	movs	r2, #0
 8001c7c:	4639      	mov	r1, r7
 8001c7e:	4620      	mov	r0, r4
 8001c80:	f7ff fee7 	bl	8001a52 <LL_GPIO_SetPinPull>

    LL_GPIO_SetPinMode(BOARD_UART1_TX_GPIO, BOARD_UART1_TX_PIN, LL_GPIO_MODE_OUTPUT);
 8001c84:	2201      	movs	r2, #1
 8001c86:	2140      	movs	r1, #64	; 0x40
 8001c88:	4620      	mov	r0, r4
 8001c8a:	f7ff feb0 	bl	80019ee <LL_GPIO_SetPinMode>
	LL_GPIO_SetPinPull(BOARD_UART1_TX_GPIO, BOARD_UART1_TX_PIN, LL_GPIO_PULL_NO);
 8001c8e:	2200      	movs	r2, #0
 8001c90:	2140      	movs	r1, #64	; 0x40
 8001c92:	4620      	mov	r0, r4
 8001c94:	f7ff fedd 	bl	8001a52 <LL_GPIO_SetPinPull>
	LL_GPIO_SetPinSpeed(BOARD_UART1_TX_GPIO, BOARD_UART1_TX_PIN, LL_GPIO_SPEED_FREQ_LOW);
 8001c98:	2200      	movs	r2, #0
 8001c9a:	2140      	movs	r1, #64	; 0x40
 8001c9c:	4620      	mov	r0, r4
 8001c9e:	f7ff febf 	bl	8001a20 <LL_GPIO_SetPinSpeed>
  WRITE_REG(GPIOx->BRR, PinMask);
 8001ca2:	2340      	movs	r3, #64	; 0x40
 8001ca4:	62a3      	str	r3, [r4, #40]	; 0x28



	/* Set radio refresh period and schedule reset packet transmission */
//	bool app_setTxScheduled();
    ApplicationEventFlags.ResetDetected = 1;
 8001ca6:	4b0e      	ldr	r3, [pc, #56]	; (8001ce0 <main+0x1ec>)
 8001ca8:	881a      	ldrh	r2, [r3, #0]
 8001caa:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8001cae:	801a      	strh	r2, [r3, #0]
    ApplicationEventFlags.BlowIsActive = 1;
    ncp_uart_init();
#else


    ApplicationEventFlags.BlowCountEnable = 1;
 8001cb0:	881a      	ldrh	r2, [r3, #0]
 8001cb2:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8001cb6:	801a      	strh	r2, [r3, #0]
  WRITE_REG(GPIOx->BSRR, PinMask);
 8001cb8:	f44f 7380 	mov.w	r3, #256	; 0x100
 8001cbc:	61a3      	str	r3, [r4, #24]
void main_loop()
{



	while (1) {
 8001cbe:	e7fe      	b.n	8001cbe <main+0x1ca>
 8001cc0:	20004b24 	.word	0x20004b24
 8001cc4:	08001ef4 	.word	0x08001ef4
 8001cc8:	080019e1 	.word	0x080019e1
 8001ccc:	40003000 	.word	0x40003000
 8001cd0:	e000ed00 	.word	0xe000ed00
 8001cd4:	05fa0300 	.word	0x05fa0300
 8001cd8:	48000400 	.word	0x48000400
 8001cdc:	48001c00 	.word	0x48001c00
 8001ce0:	20004250 	.word	0x20004250
 8001ce4:	48000800 	.word	0x48000800

08001ce8 <hse_init>:
    NVIC_EnableIRQ(SysTick_IRQn);
}

//#define MSI48_to_HSE48
void hse_init()
{
 8001ce8:	b538      	push	{r3, r4, r5, lr}
  *         (*) value not defined in all devices.
  * @retval None
  */
__STATIC_INLINE void LL_FLASH_SetLatency(uint32_t Latency)
{
  MODIFY_REG(FLASH->ACR, FLASH_ACR_LATENCY, Latency);
 8001cea:	4a26      	ldr	r2, [pc, #152]	; (8001d84 <hse_init+0x9c>)
 8001cec:	6813      	ldr	r3, [r2, #0]
 8001cee:	f023 0307 	bic.w	r3, r3, #7
 8001cf2:	f043 0302 	orr.w	r3, r3, #2
 8001cf6:	6013      	str	r3, [r2, #0]
  *
  *         (*) value not defined in all devices.
  */
__STATIC_INLINE uint32_t LL_FLASH_GetLatency(void)
{
  return (uint32_t)(READ_BIT(FLASH->ACR, FLASH_ACR_LATENCY));
 8001cf8:	6813      	ldr	r3, [r2, #0]
 8001cfa:	f003 0307 	and.w	r3, r3, #7
	LL_FLASH_SetLatency(LL_FLASH_LATENCY_2);
	if (LL_FLASH_GetLatency() != LL_FLASH_LATENCY_2)
 8001cfe:	2b02      	cmp	r3, #2
 8001d00:	d000      	beq.n	8001d04 <hse_init+0x1c>
		for (;;);
 8001d02:	e7fe      	b.n	8001d02 <hse_init+0x1a>
  *         @arg @ref LL_PWR_REGU_VOLTAGE_SCALE2
  * @retval None
  */
__STATIC_INLINE void LL_PWR_SetRegulVoltageScaling(uint32_t VoltageScaling)
{
  MODIFY_REG(PWR->CR1, PWR_CR1_VOS, VoltageScaling);
 8001d04:	4a20      	ldr	r2, [pc, #128]	; (8001d88 <hse_init+0xa0>)
 8001d06:	6813      	ldr	r3, [r2, #0]
 8001d08:	f423 63c0 	bic.w	r3, r3, #1536	; 0x600
 8001d0c:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8001d10:	6013      	str	r3, [r2, #0]
  * @rmtoll CR           HSEON         LL_RCC_HSE_Enable
  * @retval None
  */
__STATIC_INLINE void LL_RCC_HSE_Enable(void)
{
  SET_BIT(RCC->CR, RCC_CR_HSEON);
 8001d12:	f502 32d0 	add.w	r2, r2, #106496	; 0x1a000
 8001d16:	6813      	ldr	r3, [r2, #0]
 8001d18:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8001d1c:	6013      	str	r3, [r2, #0]
  *         @arg @ref LL_RCC_MSIRANGE_11
  * @retval None
  */
__STATIC_INLINE void LL_RCC_MSI_SetRange(uint32_t Range)
{
  MODIFY_REG(RCC->CR, RCC_CR_MSIRANGE, Range);
 8001d1e:	6813      	ldr	r3, [r2, #0]
 8001d20:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8001d24:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8001d28:	6013      	str	r3, [r2, #0]
  return ((READ_BIT(RCC->CR, RCC_CR_HSERDY) == RCC_CR_HSERDY) ? 1UL : 0UL);
 8001d2a:	6813      	ldr	r3, [r2, #0]
 8001d2c:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8001d30:	d0fb      	beq.n	8001d2a <hse_init+0x42>
  SET_BIT(RCC->CR, RCC_CR_CSSON);
 8001d32:	4b16      	ldr	r3, [pc, #88]	; (8001d8c <hse_init+0xa4>)
 8001d34:	681a      	ldr	r2, [r3, #0]
 8001d36:	f442 2200 	orr.w	r2, r2, #524288	; 0x80000
 8001d3a:	601a      	str	r2, [r3, #0]
  *         @arg @ref LL_RCC_SYS_CLKSOURCE_PLL
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetSysClkSource(uint32_t Source)
{
  MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, Source);
 8001d3c:	689a      	ldr	r2, [r3, #8]
 8001d3e:	f022 0203 	bic.w	r2, r2, #3
 8001d42:	f042 0202 	orr.w	r2, r2, #2
 8001d46:	609a      	str	r2, [r3, #8]
  *         @arg @ref LL_RCC_SYSCLK_DIV_512
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetAHBPrescaler(uint32_t Prescaler)
{
  MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, Prescaler);
 8001d48:	689a      	ldr	r2, [r3, #8]
 8001d4a:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8001d4e:	609a      	str	r2, [r3, #8]
  *         @arg @ref LL_RCC_APB1_DIV_16
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetAPB1Prescaler(uint32_t Prescaler)
{
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, Prescaler);
 8001d50:	689a      	ldr	r2, [r3, #8]
 8001d52:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 8001d56:	609a      	str	r2, [r3, #8]
  *         @arg @ref LL_RCC_APB2_DIV_16
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetAPB2Prescaler(uint32_t Prescaler)
{
  MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, Prescaler);
 8001d58:	689a      	ldr	r2, [r3, #8]
 8001d5a:	f422 5260 	bic.w	r2, r2, #14336	; 0x3800
 8001d5e:	609a      	str	r2, [r3, #8]
	LL_Init1msTick(freq);
 8001d60:	4d0b      	ldr	r5, [pc, #44]	; (8001d90 <hse_init+0xa8>)
 8001d62:	4628      	mov	r0, r5
 8001d64:	f000 f838 	bl	8001dd8 <LL_Init1msTick>
  */
__STATIC_INLINE void LL_SYSTICK_SetClkSource(uint32_t Source)
{
  if (Source == LL_SYSTICK_CLKSOURCE_HCLK)
  {
    SET_BIT(SysTick->CTRL, LL_SYSTICK_CLKSOURCE_HCLK);
 8001d68:	f04f 24e0 	mov.w	r4, #3758153728	; 0xe000e000
 8001d6c:	6923      	ldr	r3, [r4, #16]
 8001d6e:	f043 0304 	orr.w	r3, r3, #4
 8001d72:	6123      	str	r3, [r4, #16]
	LL_SetSystemCoreClock(freq);
 8001d74:	4628      	mov	r0, r5
 8001d76:	f000 f83f 	bl	8001df8 <LL_SetSystemCoreClock>
    SysTick->CTRL |= SysTick_CTRL_TICKINT_Msk;
 8001d7a:	6923      	ldr	r3, [r4, #16]
 8001d7c:	f043 0302 	orr.w	r3, r3, #2
 8001d80:	6123      	str	r3, [r4, #16]
	LL_RCC_SetAPB1Prescaler(LL_RCC_APB1_DIV_1);
	LL_RCC_SetAPB2Prescaler(LL_RCC_APB2_DIV_1);

    systick_init( 48000000 );
#endif
}
 8001d82:	bd38      	pop	{r3, r4, r5, pc}
 8001d84:	40022000 	.word	0x40022000
 8001d88:	40007000 	.word	0x40007000
 8001d8c:	40021000 	.word	0x40021000
 8001d90:	02dc6c00 	.word	0x02dc6c00

08001d94 <clock_init>:

void clock_init()
{
 8001d94:	b500      	push	{lr}
 8001d96:	b083      	sub	sp, #12
    //clock_4msi_to_48msi();
	hse_init();
 8001d98:	f7ff ffa6 	bl	8001ce8 <hse_init>
  * @retval None
*/
__STATIC_INLINE void LL_AHB2_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->AHB2ENR, Periphs);
 8001d9c:	4b0d      	ldr	r3, [pc, #52]	; (8001dd4 <clock_init+0x40>)
 8001d9e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8001da0:	f04f 32ff 	mov.w	r2, #4294967295
 8001da4:	64da      	str	r2, [r3, #76]	; 0x4c
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->AHB2ENR, Periphs);
 8001da6:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8001da8:	9201      	str	r2, [sp, #4]
  (void)tmpreg;
 8001daa:	9a01      	ldr	r2, [sp, #4]
  * @retval None
*/
__STATIC_INLINE void LL_APB1_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB1ENR1, Periphs);
 8001dac:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8001dae:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8001db2:	659a      	str	r2, [r3, #88]	; 0x58
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB1ENR1, Periphs);
 8001db4:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8001db6:	f002 5280 	and.w	r2, r2, #268435456	; 0x10000000
 8001dba:	9200      	str	r2, [sp, #0]
  (void)tmpreg;
 8001dbc:	9a00      	ldr	r2, [sp, #0]
  *         @arg @ref LL_RCC_STOP_WAKEUPCLOCK_HSI
  * @retval None
  */
__STATIC_INLINE void LL_RCC_SetClkAfterWakeFromStop(uint32_t Clock)
{
  MODIFY_REG(RCC->CFGR, RCC_CFGR_STOPWUCK, Clock);
 8001dbe:	689a      	ldr	r2, [r3, #8]
 8001dc0:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8001dc4:	609a      	str	r2, [r3, #8]
  SET_BIT(RCC->CR, RCC_CR_MSIRGSEL);
 8001dc6:	681a      	ldr	r2, [r3, #0]
 8001dc8:	f042 0208 	orr.w	r2, r2, #8
 8001dcc:	601a      	str	r2, [r3, #0]
	LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_PWR);

	/* Ensure that MSI is wake-up system clock */
	LL_RCC_SetClkAfterWakeFromStop(LL_RCC_STOP_WAKEUPCLOCK_MSI);
    LL_RCC_MSI_EnableRangeSelection();
}
 8001dce:	b003      	add	sp, #12
 8001dd0:	f85d fb04 	ldr.w	pc, [sp], #4
 8001dd4:	40021000 	.word	0x40021000

08001dd8 <LL_Init1msTick>:
  * @retval None
  */
__STATIC_INLINE void LL_InitTick(uint32_t HCLKFrequency, uint32_t Ticks)
{
  /* Configure the SysTick to have interrupt in 1ms time base */
  SysTick->LOAD  = (uint32_t)((HCLKFrequency / Ticks) - 1UL);  /* set reload register */
 8001dd8:	4b06      	ldr	r3, [pc, #24]	; (8001df4 <LL_Init1msTick+0x1c>)
 8001dda:	fba3 2300 	umull	r2, r3, r3, r0
 8001dde:	099b      	lsrs	r3, r3, #6
 8001de0:	3b01      	subs	r3, #1
 8001de2:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
 8001de6:	6153      	str	r3, [r2, #20]
  SysTick->VAL   = 0UL;                                       /* Load the SysTick Counter Value */
 8001de8:	2300      	movs	r3, #0
 8001dea:	6193      	str	r3, [r2, #24]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8001dec:	2305      	movs	r3, #5
 8001dee:	6113      	str	r3, [r2, #16]
  */
void LL_Init1msTick(uint32_t HCLKFrequency)
{
  /* Use frequency provided in argument */
  LL_InitTick(HCLKFrequency, 1000U);
}
 8001df0:	4770      	bx	lr
 8001df2:	bf00      	nop
 8001df4:	10624dd3 	.word	0x10624dd3

08001df8 <LL_SetSystemCoreClock>:
  * @retval None
  */
void LL_SetSystemCoreClock(uint32_t HCLKFrequency)
{
  /* HCLK clock frequency */
  SystemCoreClock = HCLKFrequency;
 8001df8:	4b01      	ldr	r3, [pc, #4]	; (8001e00 <LL_SetSystemCoreClock+0x8>)
 8001dfa:	6018      	str	r0, [r3, #0]
}
 8001dfc:	4770      	bx	lr
 8001dfe:	bf00      	nop
 8001e00:	20000008 	.word	0x20000008

08001e04 <Reset_Handler>:

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack    /* Set stack pointer */
 8001e04:	f8df d030 	ldr.w	sp, [pc, #48]	; 8001e38 <LoopForever+0x2>

/* Call the clock system initialization function.*/
//    bl  SystemInit

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
 8001e08:	2100      	movs	r1, #0
  b	LoopCopyDataInit
 8001e0a:	e003      	b.n	8001e14 <LoopCopyDataInit>

08001e0c <CopyDataInit>:

CopyDataInit:
	ldr	r3, =_sidata
 8001e0c:	4b0b      	ldr	r3, [pc, #44]	; (8001e3c <LoopForever+0x6>)
	ldr	r3, [r3, r1]
 8001e0e:	585b      	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
 8001e10:	5043      	str	r3, [r0, r1]
	adds	r1, r1, #4
 8001e12:	3104      	adds	r1, #4

08001e14 <LoopCopyDataInit>:

LoopCopyDataInit:
	ldr	r0, =_sdata
 8001e14:	480a      	ldr	r0, [pc, #40]	; (8001e40 <LoopForever+0xa>)
	ldr	r3, =_edata
 8001e16:	4b0b      	ldr	r3, [pc, #44]	; (8001e44 <LoopForever+0xe>)
	adds	r2, r0, r1
 8001e18:	1842      	adds	r2, r0, r1
	cmp	r2, r3
 8001e1a:	429a      	cmp	r2, r3
	bcc	CopyDataInit
 8001e1c:	d3f6      	bcc.n	8001e0c <CopyDataInit>
	ldr	r2, =_sbss
 8001e1e:	4a0a      	ldr	r2, [pc, #40]	; (8001e48 <LoopForever+0x12>)
	b	LoopFillZerobss
 8001e20:	e002      	b.n	8001e28 <LoopFillZerobss>

08001e22 <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
 8001e22:	2300      	movs	r3, #0
	str	r3, [r2], #4
 8001e24:	f842 3b04 	str.w	r3, [r2], #4

08001e28 <LoopFillZerobss>:

LoopFillZerobss:
	ldr	r3, = _ebss
 8001e28:	4b08      	ldr	r3, [pc, #32]	; (8001e4c <LoopForever+0x16>)
	cmp	r2, r3
 8001e2a:	429a      	cmp	r2, r3
	bcc	FillZerobss
 8001e2c:	d3f9      	bcc.n	8001e22 <FillZerobss>

/* Call static constructors */
    bl __libc_init_array
 8001e2e:	f000 f80f 	bl	8001e50 <__libc_init_array>
/* Call the application's entry point.*/
	bl	main
 8001e32:	f7ff fe5f 	bl	8001af4 <main>

08001e36 <LoopForever>:

LoopForever:
    b LoopForever
 8001e36:	e7fe      	b.n	8001e36 <LoopForever>
  ldr   sp, =_estack    /* Set stack pointer */
 8001e38:	2000a000 	.word	0x2000a000
	ldr	r3, =_sidata
 8001e3c:	08001f08 	.word	0x08001f08
	ldr	r0, =_sdata
 8001e40:	20000000 	.word	0x20000000
	ldr	r3, =_edata
 8001e44:	2000000c 	.word	0x2000000c
	ldr	r2, =_sbss
 8001e48:	2000000c 	.word	0x2000000c
	ldr	r3, = _ebss
 8001e4c:	20004b28 	.word	0x20004b28

08001e50 <__libc_init_array>:
 8001e50:	b570      	push	{r4, r5, r6, lr}
 8001e52:	4d0d      	ldr	r5, [pc, #52]	; (8001e88 <__libc_init_array+0x38>)
 8001e54:	4c0d      	ldr	r4, [pc, #52]	; (8001e8c <__libc_init_array+0x3c>)
 8001e56:	1b64      	subs	r4, r4, r5
 8001e58:	10a4      	asrs	r4, r4, #2
 8001e5a:	2600      	movs	r6, #0
 8001e5c:	42a6      	cmp	r6, r4
 8001e5e:	d109      	bne.n	8001e74 <__libc_init_array+0x24>
 8001e60:	4d0b      	ldr	r5, [pc, #44]	; (8001e90 <__libc_init_array+0x40>)
 8001e62:	4c0c      	ldr	r4, [pc, #48]	; (8001e94 <__libc_init_array+0x44>)
 8001e64:	f000 f82e 	bl	8001ec4 <_init>
 8001e68:	1b64      	subs	r4, r4, r5
 8001e6a:	10a4      	asrs	r4, r4, #2
 8001e6c:	2600      	movs	r6, #0
 8001e6e:	42a6      	cmp	r6, r4
 8001e70:	d105      	bne.n	8001e7e <__libc_init_array+0x2e>
 8001e72:	bd70      	pop	{r4, r5, r6, pc}
 8001e74:	f855 3b04 	ldr.w	r3, [r5], #4
 8001e78:	4798      	blx	r3
 8001e7a:	3601      	adds	r6, #1
 8001e7c:	e7ee      	b.n	8001e5c <__libc_init_array+0xc>
 8001e7e:	f855 3b04 	ldr.w	r3, [r5], #4
 8001e82:	4798      	blx	r3
 8001e84:	3601      	adds	r6, #1
 8001e86:	e7f2      	b.n	8001e6e <__libc_init_array+0x1e>
 8001e88:	08001f00 	.word	0x08001f00
 8001e8c:	08001f00 	.word	0x08001f00
 8001e90:	08001f00 	.word	0x08001f00
 8001e94:	08001f04 	.word	0x08001f04

08001e98 <memcpy>:
 8001e98:	440a      	add	r2, r1
 8001e9a:	4291      	cmp	r1, r2
 8001e9c:	f100 33ff 	add.w	r3, r0, #4294967295
 8001ea0:	d100      	bne.n	8001ea4 <memcpy+0xc>
 8001ea2:	4770      	bx	lr
 8001ea4:	b510      	push	{r4, lr}
 8001ea6:	f811 4b01 	ldrb.w	r4, [r1], #1
 8001eaa:	f803 4f01 	strb.w	r4, [r3, #1]!
 8001eae:	4291      	cmp	r1, r2
 8001eb0:	d1f9      	bne.n	8001ea6 <memcpy+0xe>
 8001eb2:	bd10      	pop	{r4, pc}

08001eb4 <memset>:
 8001eb4:	4402      	add	r2, r0
 8001eb6:	4603      	mov	r3, r0
 8001eb8:	4293      	cmp	r3, r2
 8001eba:	d100      	bne.n	8001ebe <memset+0xa>
 8001ebc:	4770      	bx	lr
 8001ebe:	f803 1b01 	strb.w	r1, [r3], #1
 8001ec2:	e7f9      	b.n	8001eb8 <memset+0x4>

08001ec4 <_init>:
 8001ec4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001ec6:	bf00      	nop
 8001ec8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8001eca:	bc08      	pop	{r3}
 8001ecc:	469e      	mov	lr, r3
 8001ece:	4770      	bx	lr

08001ed0 <_fini>:
 8001ed0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001ed2:	bf00      	nop
 8001ed4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8001ed6:	bc08      	pop	{r3}
 8001ed8:	469e      	mov	lr, r3
 8001eda:	4770      	bx	lr
